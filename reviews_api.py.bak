"""

Log in


AffiliateAudit(referral_codes [AffiliateCode], action_taken, action_date, user [User], ip_address, device_info, location)
 
AffiliateCampaign(programs [AffiliateProgram], campaign_name, start_date, end_date, goal, budget, spending_to_date, target_audience)

AffiliateCommission(affiliates [Affiliate], programs [AffiliateProgram], amount, currency, date_awarded, status, approved_by, commission_type, description, tier) 

AffiliateIncentive(affiliate, program, incentive_type, date, amount, currency, status, description, ip_address, device_info, tracking_id, expiration_date is_incentive_active)

AffiliateLink(affiliates [Affiliate], programs [AffiliateProgram], url, click_count, conversion_count, date_created, last_used, link_status, landing_page, custom_tracking_id)

AffiliateNotification(user [User], message, date_sent, is_read, notification_type, priority, action_required)

AffiliatePayout(affiliates [Affiliate], amount, currency, payout_date, payout_method, payout_status, transaction_id, processing_fee, net_amount, payout_provider)

AffiliateProgramPartecipation(referral_codes, programs, date_joined, reward_earned, status)

AffiliateProgram(name, description, reward_type, reward_value, currency, min_referral_count, max_referrals_per_user, date_created, is_active, program_duration, allowed_regions, target_industry)

AffiliateReward(referral_codes [AffiliateCode], referred_user [User], reward_type, reward_value, date_awarded, status, expiry_date, reward_description, reward_source)

AffiliateSettings(user [User], default_reward_type, max_referrals_allowed, notification_preference, auto_share_setting, social_share_message)

AffiliateSupportTicket(affiliates [Affiliate], ticket_number, subject, description, status, date_created, date_closed, priority, assigned_agent)

AffiliateTier(programs [AffiliateProgram], tier_name, min_sales, commission_rate, tier_benefits, access_level, next_tier_threshold, tier_expiration)

AffiliateTransaction(referral_codes [AffiliateCode], referred_user [User], transaction_date, order_id, transaction_amount, currency, status, conversion_value, discount_value, coupon_code_used, channel)


ReferralAudit(referral_codes [ReferralCode], action_taken, action_date, user [User], ip_address, device_info, location)

ReferralBonus(programs [ReferralProgram], bonus_type, bonus_value, min_referrals_required, bonus_date, expiry_date, max_usage, eligibility_criteria)

ReferralCampaign(programs [ReferralProgram], campaign_name, start_date, end_date, goal, budget, spending_to_date, target_audience)

ReferralCode(user [User], programs [ReferralProgram], code, usage_count, date_created, status, expiry_date, referred_user_count, unique_url, campaign_source, campaign_medium)

ReferralConversion(referral_codes [ReferralCode], referred_user [User], conversion_date, conversion_value, status, reward_issued, conversion_source, referral_type)

ReferralEngagement(referral_codes [ReferralCode], user [User], email_opened, email_clicked, social_share_count, last_interaction_date)

ReferralNotification(user [User], message, date_sent, is_read, notification_type, priority, action_required)

ReferralProgramPartecipation(referral_codes, programs, date_joined, reward_earned, status)

ReferralProgram(name, description, reward_type, reward_value, currency, min_referral_count, max_referrals_per_user, date_created, is_active, program_duration, allowed_regions, target_industry)

ReferralReward(referral_codes [ReferralCode], referred_user [User], reward_type, reward_value, date_awarded, status, expiry_date, reward_description, reward_source)

ReferralSettings(user [User], default_reward_type, max_referrals_allowed, notification_preference, auto_share_setting, social_share_message)

ReferralStats(referral_codes [ReferralCode], period, click_count, conversion_count, total_rewards, average_conversion_value, highest_referral_earning)

ReferralTransaction(referral_codes [ReferralCode], referred_user [User], transaction_date, order_id, transaction_amount, currency, status, conversion_value, discount_value, coupon_code_used, channel)

ReferralUser(user [User], total_referrals, active_referrals, inactive_referrals, total_rewards_earned, total_spent_by_referred_users, average_order_value, loyalty_points_earned)

Referral(program, referrer, referred, reward_given)
 
Questo qui è lo schema del mio sistema di affiliazione e sistema di codici referenziati.

Di seguito ti mostro un esempio dei miei attuali servizi importato poi nella views API:
"""

import logging

from typing import List 
from django.contrib.auth import get_user_model

from referral.models.referral_bonus import ReferralBonus
from referral.models.referral_program import ReferralProgram

User = get_user_model()

# Set up a logger
logger = logging.getLogger(__name__)


class ReferralBonusService():
    def __init__(self) -> None:
        pass
    
    def get_referral_bonus(self) -> List[ReferralBonus]:
        try:
            referral_bonus = ReferralBonus.objects.all() 
            return referral_bonus
        except ReferralBonus.DoesNotExist:
            logger.warning(f"ReferralBonus not found")
            raise ValueError("ReferralBonus not found")
     
    def get_referral_bonus(self, pk) -> ReferralBonus:
        try:
            referral_bonus = ReferralBonus.objects.get(id=pk)
            return referral_bonus
        except ReferralBonus.DoesNotExist:
            logger.warning(f"ReferralBonus not found: {pk}")
            raise ValueError("ReferralBonus not found")
     
    def create_referral_bonus(self, data) -> ReferralBonus:
        try:
            referral_bonus = ReferralBonus(
                bonus_type = data.get('bonus_type'),
                bonus_value = data.get('bonus_value'), 
                min_referrals_required = data.get('min_referrals_required'),
                bonus_date = data.get('bonus_date'),
                expiry_date = data.get('expiry_date'),
                max_usage = data.get('max_usage'),
                eligibility_criteria = data.get('eligibility_criteria')
            )
            referral_bonus.save()

            referral_programs = ReferralProgram.objects.filter(id__in=data['referral_programs'])
            referral_bonus.programs.set(referral_programs)

            logger.info(f"ReferralBonus created: {referral_bonus}")
            return referral_bonus
        except Exception as e:
            logger.error(f"Error creating referral_bonus: {e}")
            raise e
 
    def update_referral_bonus(self, pk, data) -> ReferralBonus:
        try:
            referral_bonus = self.get_referral_bonus(pk)
            for key, value in data.items():
                setattr(referral_bonus, key, value)
            referral_bonus.save()
            logger.info(f"ReferralBonus updated: {referral_bonus}")
            return referral_bonus
        except ReferralBonus.DoesNotExist:
            logger.warning(f"ReferralBonus not found: {pk}")
            raise ValueError("ReferralBonus not found")
        except Exception as e:
            logger.error(f"Error updating referral_bonus: {e}")
            raise e
    
    def delete_referral_bonus(self, pk) -> None:
        try:
            referral_bonus = self.get_referral_bonus(pk)
            referral_bonus.delete()
            logger.info(f"ReferralBonus deleted: {referral_bonus}")
        except ReferralBonus.DoesNotExist:
            logger.warning(f"ReferralBonus not found: {pk}")
            raise ValueError("ReferralBonus not found")
        except Exception as e:
            logger.error(f"Error deleting referral_bonus: {e}")
            raise e
  


import logging
from django.http import JsonResponse
from rest_framework.views import APIView
from rest_framework.permissions import IsAuthenticated, AllowAny
from rest_framework.renderers import JSONRenderer
from rest_framework.response import Response
from rest_framework import status
from oauth2_provider.contrib.rest_framework import OAuth2Authentication
from drf_yasg.utils import swagger_auto_schema
from drf_yasg import openapi
from ..services.referral_bonus_service import ReferralBonusService
from ...models.referral_bonus import ReferralBonus
from ..serializers import ReferralBonusSerializer
from dashboard.api.permissions import HasActiveSubscription

# Set up a logger
logger = logging.getLogger(__name__)

class ReferralBonusAPIView(APIView):
    permission_classes = [IsAuthenticated, HasActiveSubscription]  # [AllowAny]  or [IsAuthenticated]  or [HasActiveSubscription]
    renderer_classes = [JSONRenderer]
    authentication_classes = [OAuth2Authentication]

    def __init__(self, *args, **kwargs):
        self.referral_bonus_service = ReferralBonusService()

    @swagger_auto_schema(
        operation_summary="List all referral_bonus",
        operation_description="Returns a list of all referral_bonus entries.",
        responses={
            200: openapi.Response('Successful Response', ReferralBonusSerializer(many=True)),
            500: 'Internal Server Error'
        },
        tags=['referral_bonus']
    )
    def get(self, request, referral_bonus_id = None):
        try:
            if referral_bonus_id == None:
                referral_bonus = ReferralBonus.objects.all()
                serializer = ReferralBonusSerializer(referral_bonus, many=True)
                return Response(serializer.data, status=status.HTTP_200_OK)
            else:
                referral_bonus = self.referral_bonus_service.get_referral_bonus(referral_bonus_id)
                serializer = ReferralBonusSerializer(referral_bonus)
                return Response(serializer.data, status=status.HTTP_200_OK)  
        except ReferralBonus.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error fetching referral_bonus: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Create new referral_bonus",
        operation_description="Creates a new referral_bonus entry.",
        request_body=ReferralBonusSerializer,
        responses={
            201: openapi.Response('Created', ReferralBonusSerializer),
            400: 'Bad Request',
            500: 'Internal Server Error'
        },
        tags=['referral_bonus']
    )
    def post(self, request):
        try:
            serializer = ReferralBonusSerializer(data=request.data)
            if serializer.is_valid():
                referral_bonus = self.referral_bonus_service.create_referral_bonus(serializer.validated_data)
                return Response(ReferralBonusSerializer(referral_bonus).data, status=status.HTTP_201_CREATED)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            logger.error(f"Error creating referral_bonus: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
 
    @swagger_auto_schema(
        operation_summary="Update a referral_bonus entry",
        operation_description="Updates a specific referral_bonus entry by ID.",
        request_body=ReferralBonusSerializer,
        responses={
            200: openapi.Response('Successful Response', ReferralBonusSerializer),
            400: 'Bad Request',
            404: 'Not Found',
            500: 'Internal Server Error'
        },
        tags=['referral_bonus']
    )
    def put(self, request, referral_bonus_id=None):
        try: 
            serializer = ReferralBonusSerializer(data=request.data)
            if serializer.is_valid():
                referral_bonus = self.referral_bonus_service.update_referral_bonus(referral_bonus_id, serializer.validated_data)
                return Response(ReferralBonusSerializer(referral_bonus).data, status=status.HTTP_200_OK)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except ReferralBonus.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error updating referral_bonus: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Delete a referral_bonus entry",
        operation_description="Deletes a specific referral_bonus entry by ID.",
        responses={
            204: 'No Content',
            404: 'Not Found',
            500: 'Internal Server Error'
        },
        tags=['referral_bonus']
    )
    def delete(self, request, referral_bonus_id=None):
        try:
            referral_bonus = self.referral_bonus_service.delete_referral_bonus(referral_bonus_id)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except ReferralBonus.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error deleting referral_bonus: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

"""i service e views sono simili pero non sono funzionali come dovrebbero, dovrebbero essere interoperabili e che usano i COOKIE o altre informazioni proveniente dalle request... Mi aiuti a rendere tutti i servizi e views interoperabili?
 said:
Per rendere i tuoi servizi e le tue views interoperabili, utilizzando informazioni provenienti dalle richieste (come cookie, IP, e dati di sessione) e migliorando la gestione delle informazioni condivise tra i vari componenti, dobbiamo fare alcune modifiche chiave. In particolare, ti consiglio di:

Gestire i dati provenienti dalle richieste (come cookie e header) all'interno dei servizi.
Aggiungere un meccanismo di autenticazione e gestione delle sessioni per assicurarti che ogni richiesta venga associata correttamente a un utente.
Integrare i dati di contesto nelle operazioni (come ad esempio l’IP, il dispositivo, e i cookie) per ogni azione, registrandoli in un database se necessario.
1. Gestione dei Cookie e Dati della Richiesta nei Servizi
Puoi estrarre i dati dai cookie e altri header direttamente dalle richieste in Django, utilizzandoli nelle funzioni del servizio.

Modifica il servizio ReferralBonusService per accettare informazioni provenienti dalla richiesta (come l’IP dell'utente, i cookie, o altre informazioni utili).

Esempio di come usare l'IP e i dati provenienti dai cookie nei tuoi servizi:"""
class ReferralBonusService():
    def __init__(self, request=None) -> None:
        self.request = request  # Salviamo la richiesta per utilizzarla nei metodi

    def get_referral_bonus(self) -> List[ReferralBonus]:
        try:
            referral_bonus = ReferralBonus.objects.all() 
            self._log_request_info()  # Logga l'informazione della richiesta (ad esempio IP)
            return referral_bonus
        except ReferralBonus.DoesNotExist:
            logger.warning(f"ReferralBonus not found")
            raise ValueError("ReferralBonus not found")

    def get_referral_bonus(self, pk) -> ReferralBonus:
        try:
            referral_bonus = ReferralBonus.objects.get(id=pk)
            self._log_request_info()  # Logga l'informazione della richiesta
            return referral_bonus
        except ReferralBonus.DoesNotExist:
            logger.warning(f"ReferralBonus not found: {pk}")
            raise ValueError("ReferralBonus not found")
    
    def _log_request_info(self):
        """Logga informazioni come IP, User Agent, e cookie se necessario"""
        if self.request:
            user_ip = self.request.META.get('REMOTE_ADDR', 'Unknown')
            user_agent = self.request.META.get('HTTP_USER_AGENT', 'Unknown')
            cookies = self.request.COOKIES
            logger.info(f"Request Info - IP: {user_ip}, User-Agent: {user_agent}, Cookies: {cookies}")
"""2. Autenticazione e Gestione dell’Utente
Dovresti usare l'autenticazione dell'utente (ad esempio tramite token OAuth o sessione) per associare correttamente ogni azione all'utente che la sta eseguendo. Django Rest Framework offre già un meccanismo di autenticazione (OAuth, JWT, sessione).

Utilizzo dell'autenticazione per ottenere l'utente corrente:
In Django, puoi ottenere l'utente corrente dalla richiesta, ad esempio:"""

from rest_framework.request import Request
from django.contrib.auth.models import User

class ReferralBonusService():
    def __init__(self, request: Request = None) -> None:
        self.request = request
        self.user = self.request.user if self.request else None

    def get_referral_bonus(self) -> List[ReferralBonus]:
        try:
            referral_bonus = ReferralBonus.objects.all()
            self._log_user_info()  # Logga informazioni sull'utente
            return referral_bonus
        except ReferralBonus.DoesNotExist:
            logger.warning(f"ReferralBonus not found")
            raise ValueError("ReferralBonus not found")

    def _log_user_info(self):
        """Logga informazioni sull'utente corrente"""
        if self.user:
            logger.info(f"Request made by User: {self.user.username}, ID: {self.user.id}")
        else:
            logger.warning("Request made by unauthenticated user")
"""3. Modifica delle Views per Rendere le Richieste Interoperabili
Nelle tue views, dovrai passare la richiesta al servizio per raccogliere i dati aggiuntivi (come l'IP, i cookie, l'utente corrente). In questo modo, ogni operazione eseguita dalla view sarà correttamente associata al contesto della richiesta.

Esempio di view che passa la richiesta ai servizi:"""
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from .services.referral_bonus_service import ReferralBonusService

class ReferralBonusAPIView(APIView):
    permission_classes = [IsAuthenticated]
    authentication_classes = [OAuth2Authentication]

    def __init__(self, *args, **kwargs):
        self.referral_bonus_service = ReferralBonusService(request=self.request)  # Passiamo la request al servizio

    def get(self, request, referral_bonus_id=None):
        try:
            if referral_bonus_id is None:
                referral_bonus = self.referral_bonus_service.get_referral_bonus()
                return Response(ReferralBonusSerializer(referral_bonus, many=True).data, status=status.HTTP_200_OK)
            else:
                referral_bonus = self.referral_bonus_service.get_referral_bonus(referral_bonus_id)
                return Response(ReferralBonusSerializer(referral_bonus).data, status=status.HTTP_200_OK)
        except ReferralBonus.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def post(self, request):
        try:
            serializer = ReferralBonusSerializer(data=request.data)
            if serializer.is_valid():
                referral_bonus = self.referral_bonus_service.create_referral_bonus(serializer.validated_data)
                return Response(ReferralBonusSerializer(referral_bonus).data, status=status.HTTP_201_CREATED)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
"""4. Gestione delle Risposte e dei Log
Un aspetto importante dell'interoperabilità è gestire correttamente gli errori e i log. La gestione degli errori e dei log nelle views e nei servizi deve essere chiara, in modo che gli sviluppatori possano tracciare facilmente le informazioni sulle richieste, gli utenti e gli eventuali errori.

Aggiungi il logging dettagliato nelle views:"""
class ReferralBonusAPIView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request, referral_bonus_id=None):
        try:
            logger.info(f"GET request for referral_bonus_id: {referral_bonus_id}")
            if referral_bonus_id is None:
                referral_bonus = self.referral_bonus_service.get_referral_bonus()
                return Response(ReferralBonusSerializer(referral_bonus, many=True).data, status=status.HTTP_200_OK)
            else:
                referral_bonus = self.referral_bonus_service.get_referral_bonus(referral_bonus_id)
                return Response(ReferralBonusSerializer(referral_bonus).data, status=status.HTTP_200_OK)
        except Exception as e:
            logger.error(f"Error in GET request for referral_bonus: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
"""5. Altri Considerazioni
Gestione dei Dati di Sessione: Se desideri, puoi registrare anche i dati di sessione o altri parametri rilevanti provenienti dalla richiesta, utilizzandoli per personalizzare le operazioni.
Gestione dell’autorizzazione: Le tue views già utilizzano la classe IsAuthenticated, quindi puoi utilizzare anche altri permessi personalizzati per gestire l'accesso alle risorse, ad esempio, controllando che l'utente abbia una sottoscrizione attiva.
Queste modifiche ti aiuteranno a rendere i tuoi servizi e views interoperabili, associando correttamente le operazioni agli utenti e migliorando la gestione delle informazioni provenienti dalle richieste.




ok vorrei fare queste modifiche per tutte le classi service e classi views di tutti i modelli, iniziamo da capo, implementando completamente tutto
 said:
Perfetto! Cominceremo dall'inizio per implementare tutte le modifiche in modo completo per tutti i modelli di servizio e le views, mantenendo un'architettura chiara e interoperabile. Le modifiche riguarderanno:

Gestione delle richieste e dell'autenticazione.
Estrazione delle informazioni necessarie (cookie, IP, ecc.) dalle richieste.
Aggiornamento dei servizi per ricevere la richiesta come parametro.
Implementazione delle views per interagire con i servizi in modo interoperabile.
Ti guiderò passo per passo, iniziando dal servizio e poi passando alle views per ciascun modello, così da garantire che tutti i componenti siano ben integrati. Procederò con un modello esemplificativo e potrai adattarlo agli altri.

1. Definizione del Servizio Generico per la Gestione delle Richieste
Per ogni modello, creeremo un servizio che prenda la richiesta come parametro, in modo da poter utilizzare informazioni come l'IP, l'utente, i cookie, ecc.

Servizio Base (ReferralBonusService)
Iniziamo con il servizio per ReferralBonus. Implementeremo un servizio che accetta la richiesta e usa le informazioni dalla request.

services/referral_bonus_service.py"""
import logging
from typing import List
from referral.models.referral_bonus import ReferralBonus
from referral.models.referral_program import ReferralProgram
from django.contrib.auth import get_user_model

User = get_user_model()

# Set up a logger
logger = logging.getLogger(__name__)

class ReferralBonusService:
    def __init__(self, request=None):
        self.request = request  # Salviamo la request per utilizzarla nei metodi
        self.user = self.request.user if self.request else None

    def get_referral_bonus(self) -> List[ReferralBonus]:
        try:
            referral_bonus = ReferralBonus.objects.all()
            self._log_request_info()  # Logga l'informazione della richiesta (ad esempio IP)
            return referral_bonus
        except ReferralBonus.DoesNotExist:
            logger.warning(f"ReferralBonus not found")
            raise ValueError("ReferralBonus not found")

    def get_referral_bonus_by_id(self, pk) -> ReferralBonus:
        try:
            referral_bonus = ReferralBonus.objects.get(id=pk)
            self._log_request_info()  # Logga l'informazione della richiesta
            return referral_bonus
        except ReferralBonus.DoesNotExist:
            logger.warning(f"ReferralBonus not found: {pk}")
            raise ValueError("ReferralBonus not found")

    def create_referral_bonus(self, data) -> ReferralBonus:
        try:
            referral_bonus = ReferralBonus(
                bonus_type=data.get('bonus_type'),
                bonus_value=data.get('bonus_value'),
                min_referrals_required=data.get('min_referrals_required'),
                bonus_date=data.get('bonus_date'),
                expiry_date=data.get('expiry_date'),
                max_usage=data.get('max_usage'),
                eligibility_criteria=data.get('eligibility_criteria')
            )
            referral_bonus.save()

            referral_programs = ReferralProgram.objects.filter(id__in=data['referral_programs'])
            referral_bonus.programs.set(referral_programs)

            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"ReferralBonus created: {referral_bonus}")
            return referral_bonus
        except Exception as e:
            logger.error(f"Error creating referral_bonus: {e}")
            raise e

    def update_referral_bonus(self, pk, data) -> ReferralBonus:
        try:
            referral_bonus = self.get_referral_bonus_by_id(pk)
            for key, value in data.items():
                setattr(referral_bonus, key, value)
            referral_bonus.save()
            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"ReferralBonus updated: {referral_bonus}")
            return referral_bonus
        except ReferralBonus.DoesNotExist:
            logger.warning(f"ReferralBonus not found: {pk}")
            raise ValueError("ReferralBonus not found")
        except Exception as e:
            logger.error(f"Error updating referral_bonus: {e}")
            raise e

    def delete_referral_bonus(self, pk) -> None:
        try:
            referral_bonus = self.get_referral_bonus_by_id(pk)
            referral_bonus.delete()
            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"ReferralBonus deleted: {referral_bonus}")
        except ReferralBonus.DoesNotExist:
            logger.warning(f"ReferralBonus not found: {pk}")
            raise ValueError("ReferralBonus not found")
        except Exception as e:
            logger.error(f"Error deleting referral_bonus: {e}")
            raise e

    def _log_request_info(self):
        """Logga informazioni come IP, User Agent, e cookie se necessario"""
        if self.request:
            user_ip = self.request.META.get('REMOTE_ADDR', 'Unknown')
            user_agent = self.request.META.get('HTTP_USER_AGENT', 'Unknown')
            cookies = self.request.COOKIES
            logger.info(f"Request Info - IP: {user_ip}, User-Agent: {user_agent}, Cookies: {cookies}")
"""2. Definizione delle Views per il ReferralBonus
Ora che il servizio è pronto, passiamo alla view che interagirà con il servizio. La view prenderà la richiesta e passerà le informazioni necessarie al servizio.

views/referral_bonus_views.py"""
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from .services.referral_bonus_service import ReferralBonusService
from .serializers import ReferralBonusSerializer
from drf_yasg.utils import swagger_auto_schema
from drf_yasg import openapi
from oauth2_provider.contrib.rest_framework import OAuth2Authentication
from rest_framework.permissions import IsAuthenticated

logger = logging.getLogger(__name__)

class ReferralBonusAPIView(APIView):
    permission_classes = [IsAuthenticated]
    authentication_classes = [OAuth2Authentication]

    def __init__(self, *args, **kwargs):
        self.referral_bonus_service = ReferralBonusService(request=self.request)  # Passiamo la request al servizio

    @swagger_auto_schema(
        operation_summary="List all referral bonuses",
        operation_description="Returns a list of all referral_bonus entries.",
        responses={200: openapi.Response('Successful Response', ReferralBonusSerializer(many=True))},
        tags=['referral_bonus']
    )
    def get(self, request, referral_bonus_id=None):
        try:
            if referral_bonus_id is None:
                referral_bonus = self.referral_bonus_service.get_referral_bonus()
                return Response(ReferralBonusSerializer(referral_bonus, many=True).data, status=status.HTTP_200_OK)
            else:
                referral_bonus = self.referral_bonus_service.get_referral_bonus_by_id(referral_bonus_id)
                return Response(ReferralBonusSerializer(referral_bonus).data, status=status.HTTP_200_OK)
        except ReferralBonus.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error fetching referral_bonus: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Create a new referral bonus",
        operation_description="Creates a new referral_bonus entry.",
        request_body=ReferralBonusSerializer,
        responses={201: openapi.Response('Created', ReferralBonusSerializer)},
        tags=['referral_bonus']
    )
    def post(self, request):
        try:
            serializer = ReferralBonusSerializer(data=request.data)
            if serializer.is_valid():
                referral_bonus = self.referral_bonus_service.create_referral_bonus(serializer.validated_data)
                return Response(ReferralBonusSerializer(referral_bonus).data, status=status.HTTP_201_CREATED)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            logger.error(f"Error creating referral_bonus: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Update a referral bonus entry",
        operation_description="Updates a specific referral_bonus entry by ID.",
        request_body=ReferralBonusSerializer,
        responses={200: openapi.Response('Successful Response', ReferralBonusSerializer)},
        tags=['referral_bonus']
    )
    def put(self, request, referral_bonus_id=None):
        try:
            serializer = ReferralBonusSerializer(data=request.data)
            if serializer.is_valid():
                referral_bonus = self.referral_bonus_service.update_referral_bonus(referral_bonus_id, serializer.validated_data)
                return Response(ReferralBonusSerializer(referral_bonus).data, status=status.HTTP_200_OK)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except ReferralBonus.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error updating referral_bonus: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Delete a referral bonus entry",
        operation_description="Deletes a specific referral_bonus entry by ID.",
        responses={204: 'No Content'},
        tags=['referral_bonus']
    )
    def delete(self, request, referral_bonus_id=None):
        try:
            self.referral_bonus_service.delete_referral_bonus(referral_bonus_id)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except ReferralBonus.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error deleting referral_bonus: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
"""3. Procediamo con gli Altri Modelli
Adesso, puoi seguire lo stesso schema per gli altri modelli come AffiliateBonus, ReferralProgram, ecc.

Servizi: Crea un servizio per ciascun modello, dove implementi le operazioni CRUD come abbiamo fatto con ReferralBonus.
Views: Crea le views per ciascun servizio, passando sempre la richiesta per garantire l'accesso alle informazioni dell'utente.
Conclusione
Con questa struttura, ogni servizio riceve informazioni complete dalla richiesta e può interagire correttamente con i dati provenienti dall'utente, come l'IP, i cookie, e l'autenticazione. Ogni modifica può essere facilmente adattata per altri modelli, seguendo questo schema. Se desideri vedere un altro modello o qualche dettaglio aggiuntivo, fammi sapere!



si procediamo, io ti chiederò di proseguire ogni volta che termina l'implementazione di un service e view per un entità
 said:
Perfetto! Procederemo passo per passo, implementando prima il servizio e la view per un'entità e, una volta terminato, passeremo al modello successivo quando me lo dirai.

Per cominciare, ti propongo di implementare il servizio e la view per un altro modello, per esempio AffiliateBonus. Procederò con la definizione del servizio e della view, simile a quanto fatto per ReferralBonus.

1. Servizio per AffiliateBonus
Creiamo prima il servizio, che gestisce le operazioni CRUD per AffiliateBonus. Assumiamo che la struttura di AffiliateBonus sia simile a quella di ReferralBonus, ma con un focus sul tipo di bonus legato agli affiliati.

services/affiliate_bonus_service.py"""
import logging
from typing import List
from affiliate.models.affiliate_bonus import AffiliateBonus
from affiliate.models.affiliate_program import AffiliateProgram
from django.contrib.auth import get_user_model

User = get_user_model()

# Set up a logger
logger = logging.getLogger(__name__)

class AffiliateBonusService:
    def __init__(self, request=None):
        self.request = request  # Salviamo la request per utilizzarla nei metodi
        self.user = self.request.user if self.request else None

    def get_affiliate_bonus(self) -> List[AffiliateBonus]:
        try:
            affiliate_bonus = AffiliateBonus.objects.all()
            self._log_request_info()  # Logga l'informazione della richiesta (ad esempio IP)
            return affiliate_bonus
        except AffiliateBonus.DoesNotExist:
            logger.warning(f"AffiliateBonus not found")
            raise ValueError("AffiliateBonus not found")

    def get_affiliate_bonus_by_id(self, pk) -> AffiliateBonus:
        try:
            affiliate_bonus = AffiliateBonus.objects.get(id=pk)
            self._log_request_info()  # Logga l'informazione della richiesta
            return affiliate_bonus
        except AffiliateBonus.DoesNotExist:
            logger.warning(f"AffiliateBonus not found: {pk}")
            raise ValueError("AffiliateBonus not found")

    def create_affiliate_bonus(self, data) -> AffiliateBonus:
        try:
            affiliate_bonus = AffiliateBonus(
                bonus_type=data.get('bonus_type'),
                bonus_value=data.get('bonus_value'),
                min_affiliates_required=data.get('min_affiliates_required'),
                bonus_date=data.get('bonus_date'),
                expiry_date=data.get('expiry_date'),
                max_usage=data.get('max_usage'),
                eligibility_criteria=data.get('eligibility_criteria')
            )
            affiliate_bonus.save()

            affiliate_programs = AffiliateProgram.objects.filter(id__in=data['affiliate_programs'])
            affiliate_bonus.programs.set(affiliate_programs)

            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"AffiliateBonus created: {affiliate_bonus}")
            return affiliate_bonus
        except Exception as e:
            logger.error(f"Error creating affiliate_bonus: {e}")
            raise e

    def update_affiliate_bonus(self, pk, data) -> AffiliateBonus:
        try:
            affiliate_bonus = self.get_affiliate_bonus_by_id(pk)
            for key, value in data.items():
                setattr(affiliate_bonus, key, value)
            affiliate_bonus.save()
            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"AffiliateBonus updated: {affiliate_bonus}")
            return affiliate_bonus
        except AffiliateBonus.DoesNotExist:
            logger.warning(f"AffiliateBonus not found: {pk}")
            raise ValueError("AffiliateBonus not found")
        except Exception as e:
            logger.error(f"Error updating affiliate_bonus: {e}")
            raise e

    def delete_affiliate_bonus(self, pk) -> None:
        try:
            affiliate_bonus = self.get_affiliate_bonus_by_id(pk)
            affiliate_bonus.delete()
            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"AffiliateBonus deleted: {affiliate_bonus}")
        except AffiliateBonus.DoesNotExist:
            logger.warning(f"AffiliateBonus not found: {pk}")
            raise ValueError("AffiliateBonus not found")
        except Exception as e:
            logger.error(f"Error deleting affiliate_bonus: {e}")
            raise e

    def _log_request_info(self):
        """Logga informazioni come IP, User Agent, e cookie se necessario"""
        if self.request:
            user_ip = self.request.META.get('REMOTE_ADDR', 'Unknown')
            user_agent = self.request.META.get('HTTP_USER_AGENT', 'Unknown')
            cookies = self.request.COOKIES
            logger.info(f"Request Info - IP: {user_ip}, User-Agent: {user_agent}, Cookies: {cookies}")
"""2. View per AffiliateBonus
Ora creiamo la view per AffiliateBonus. Questa view utilizzerà il servizio appena definito per gestire le richieste e interagire con il modello.

views/affiliate_bonus_views.py"""
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from .services.affiliate_bonus_service import AffiliateBonusService
from .serializers import AffiliateBonusSerializer
from drf_yasg.utils import swagger_auto_schema
from drf_yasg import openapi
from oauth2_provider.contrib.rest_framework import OAuth2Authentication
from rest_framework.permissions import IsAuthenticated

logger = logging.getLogger(__name__)

class AffiliateBonusAPIView(APIView):
    permission_classes = [IsAuthenticated]
    authentication_classes = [OAuth2Authentication]

    def __init__(self, *args, **kwargs):
        self.affiliate_bonus_service = AffiliateBonusService(request=self.request)  # Passiamo la request al servizio

    @swagger_auto_schema(
        operation_summary="List all affiliate bonuses",
        operation_description="Returns a list of all affiliate_bonus entries.",
        responses={200: openapi.Response('Successful Response', AffiliateBonusSerializer(many=True))},
        tags=['affiliate_bonus']
    )
    def get(self, request, affiliate_bonus_id=None):
        try:
            if affiliate_bonus_id is None:
                affiliate_bonus = self.affiliate_bonus_service.get_affiliate_bonus()
                return Response(AffiliateBonusSerializer(affiliate_bonus, many=True).data, status=status.HTTP_200_OK)
            else:
                affiliate_bonus = self.affiliate_bonus_service.get_affiliate_bonus_by_id(affiliate_bonus_id)
                return Response(AffiliateBonusSerializer(affiliate_bonus).data, status=status.HTTP_200_OK)
        except AffiliateBonus.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error fetching affiliate_bonus: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Create a new affiliate bonus",
        operation_description="Creates a new affiliate_bonus entry.",
        request_body=AffiliateBonusSerializer,
        responses={201: openapi.Response('Created', AffiliateBonusSerializer)},
        tags=['affiliate_bonus']
    )
    def post(self, request):
        try:
            serializer = AffiliateBonusSerializer(data=request.data)
            if serializer.is_valid():
                affiliate_bonus = self.affiliate_bonus_service.create_affiliate_bonus(serializer.validated_data)
                return Response(AffiliateBonusSerializer(affiliate_bonus).data, status=status.HTTP_201_CREATED)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            logger.error(f"Error creating affiliate_bonus: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Update an affiliate bonus entry",
        operation_description="Updates a specific affiliate_bonus entry by ID.",
        request_body=AffiliateBonusSerializer,
        responses={200: openapi.Response('Successful Response', AffiliateBonusSerializer)},
        tags=['affiliate_bonus']
    )
    def put(self, request, affiliate_bonus_id=None):
        try:
            serializer = AffiliateBonusSerializer(data=request.data)
            if serializer.is_valid():
                affiliate_bonus = self.affiliate_bonus_service.update_affiliate_bonus(affiliate_bonus_id, serializer.validated_data)
                return Response(AffiliateBonusSerializer(affiliate_bonus).data, status=status.HTTP_200_OK)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except AffiliateBonus.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error updating affiliate_bonus: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Delete an affiliate bonus entry",
        operation_description="Deletes a specific affiliate_bonus entry by ID.",
        responses={204: 'No Content'},
        tags=['affiliate_bonus']
    )
    def delete(self, request, affiliate_bonus_id=None):
        try:
            self.affiliate_bonus_service.delete_affiliate_bonus(affiliate_bonus_id)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except AffiliateBonus.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error deleting affiliate_bonus: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
"""Conclusione
Abbiamo creato il servizio e la view per il modello AffiliateBonus. Ora siamo pronti a procedere con un altro modello, se lo desideri. Dimmi pure quando sei pronto per il prossimo!



si procedi
 said:
Perfetto, procediamo con l'implementazione per un altro modello. Passiamo a implementare il servizio e la view per il modello AffiliateCommission. Questo modello gestisce le commissioni per gli affiliati e dovrebbe avere operazioni simili a quelle precedenti.

1. Servizio per AffiliateCommission
Per prima cosa, creiamo il servizio per AffiliateCommission che gestisce tutte le operazioni CRUD.

services/affiliate_commission_service.py"""
import logging
from typing import List
from affiliate.models.affiliate_commission import AffiliateCommission
from affiliate.models.affiliate_program import AffiliateProgram
from affiliate.models.affiliate import Affiliate
from django.contrib.auth import get_user_model

User = get_user_model()

# Set up a logger
logger = logging.getLogger(__name__)

class AffiliateCommissionService:
    def __init__(self, request=None):
        self.request = request  # Salviamo la request per utilizzarla nei metodi
        self.user = self.request.user if self.request else None

    def get_affiliate_commission(self) -> List[AffiliateCommission]:
        try:
            affiliate_commissions = AffiliateCommission.objects.all()
            self._log_request_info()  # Logga l'informazione della richiesta
            return affiliate_commissions
        except AffiliateCommission.DoesNotExist:
            logger.warning(f"AffiliateCommission not found")
            raise ValueError("AffiliateCommission not found")

    def get_affiliate_commission_by_id(self, pk) -> AffiliateCommission:
        try:
            affiliate_commission = AffiliateCommission.objects.get(id=pk)
            self._log_request_info()  # Logga l'informazione della richiesta
            return affiliate_commission
        except AffiliateCommission.DoesNotExist:
            logger.warning(f"AffiliateCommission not found: {pk}")
            raise ValueError("AffiliateCommission not found")

    def create_affiliate_commission(self, data) -> AffiliateCommission:
        try:
            affiliate_commission = AffiliateCommission(
                affiliates=data.get('affiliates'),
                programs=data.get('programs'),
                amount=data.get('amount'),
                currency=data.get('currency'),
                date_awarded=data.get('date_awarded'),
                status=data.get('status'),
                approved_by=data.get('approved_by'),
                commission_type=data.get('commission_type'),
                description=data.get('description'),
                tier=data.get('tier')
            )
            affiliate_commission.save()

            affiliate_programs = AffiliateProgram.objects.filter(id__in=data['programs'])
            affiliate_commission.programs.set(affiliate_programs)

            affiliates = Affiliate.objects.filter(id__in=data['affiliates'])
            affiliate_commission.affiliates.set(affiliates)

            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"AffiliateCommission created: {affiliate_commission}")
            return affiliate_commission
        except Exception as e:
            logger.error(f"Error creating affiliate_commission: {e}")
            raise e

    def update_affiliate_commission(self, pk, data) -> AffiliateCommission:
        try:
            affiliate_commission = self.get_affiliate_commission_by_id(pk)
            for key, value in data.items():
                setattr(affiliate_commission, key, value)
            affiliate_commission.save()
            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"AffiliateCommission updated: {affiliate_commission}")
            return affiliate_commission
        except AffiliateCommission.DoesNotExist:
            logger.warning(f"AffiliateCommission not found: {pk}")
            raise ValueError("AffiliateCommission not found")
        except Exception as e:
            logger.error(f"Error updating affiliate_commission: {e}")
            raise e

    def delete_affiliate_commission(self, pk) -> None:
        try:
            affiliate_commission = self.get_affiliate_commission_by_id(pk)
            affiliate_commission.delete()
            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"AffiliateCommission deleted: {affiliate_commission}")
        except AffiliateCommission.DoesNotExist:
            logger.warning(f"AffiliateCommission not found: {pk}")
            raise ValueError("AffiliateCommission not found")
        except Exception as e:
            logger.error(f"Error deleting affiliate_commission: {e}")
            raise e

    def _log_request_info(self):
        """Logga informazioni come IP, User Agent, e cookie se necessario"""
        if self.request:
            user_ip = self.request.META.get('REMOTE_ADDR', 'Unknown')
            user_agent = self.request.META.get('HTTP_USER_AGENT', 'Unknown')
            cookies = self.request.COOKIES
            logger.info(f"Request Info - IP: {user_ip}, User-Agent: {user_agent}, Cookies: {cookies}")
"""2. View per AffiliateCommission
Ora implementiamo la view che utilizza il servizio per interagire con il modello AffiliateCommission. Questa view fornirà endpoint per le operazioni CRUD.

views/affiliate_commission_views.py"""
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from .services.affiliate_commission_service import AffiliateCommissionService
from .serializers import AffiliateCommissionSerializer
from drf_yasg.utils import swagger_auto_schema
from drf_yasg import openapi
from oauth2_provider.contrib.rest_framework import OAuth2Authentication
from rest_framework.permissions import IsAuthenticated

logger = logging.getLogger(__name__)

class AffiliateCommissionAPIView(APIView):
    permission_classes = [IsAuthenticated]
    authentication_classes = [OAuth2Authentication]

    def __init__(self, *args, **kwargs):
        self.affiliate_commission_service = AffiliateCommissionService(request=self.request)  # Passiamo la request al servizio

    @swagger_auto_schema(
        operation_summary="List all affiliate commissions",
        operation_description="Returns a list of all affiliate_commission entries.",
        responses={200: openapi.Response('Successful Response', AffiliateCommissionSerializer(many=True))},
        tags=['affiliate_commission']
    )
    def get(self, request, affiliate_commission_id=None):
        try:
            if affiliate_commission_id is None:
                affiliate_commissions = self.affiliate_commission_service.get_affiliate_commission()
                return Response(AffiliateCommissionSerializer(affiliate_commissions, many=True).data, status=status.HTTP_200_OK)
            else:
                affiliate_commission = self.affiliate_commission_service.get_affiliate_commission_by_id(affiliate_commission_id)
                return Response(AffiliateCommissionSerializer(affiliate_commission).data, status=status.HTTP_200_OK)
        except AffiliateCommission.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error fetching affiliate_commission: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Create a new affiliate commission",
        operation_description="Creates a new affiliate_commission entry.",
        request_body=AffiliateCommissionSerializer,
        responses={201: openapi.Response('Created', AffiliateCommissionSerializer)},
        tags=['affiliate_commission']
    )
    def post(self, request):
        try:
            serializer = AffiliateCommissionSerializer(data=request.data)
            if serializer.is_valid():
                affiliate_commission = self.affiliate_commission_service.create_affiliate_commission(serializer.validated_data)
                return Response(AffiliateCommissionSerializer(affiliate_commission).data, status=status.HTTP_201_CREATED)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            logger.error(f"Error creating affiliate_commission: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Update an affiliate commission entry",
        operation_description="Updates a specific affiliate_commission entry by ID.",
        request_body=AffiliateCommissionSerializer,
        responses={200: openapi.Response('Successful Response', AffiliateCommissionSerializer)},
        tags=['affiliate_commission']
    )
    def put(self, request, affiliate_commission_id=None):
        try:
            serializer = AffiliateCommissionSerializer(data=request.data)
            if serializer.is_valid():
                affiliate_commission = self.affiliate_commission_service.update_affiliate_commission(affiliate_commission_id, serializer.validated_data)
                return Response(AffiliateCommissionSerializer(affiliate_commission).data, status=status.HTTP_200_OK)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except AffiliateCommission.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error updating affiliate_commission: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Delete an affiliate commission entry",
        operation_description="Deletes a specific affiliate_commission entry by ID.",
        responses={204: 'No Content'},
        tags=['affiliate_commission']
    )
    def delete(self, request, affiliate_commission_id=None):
        try:
            self.affiliate_commission_service.delete_affiliate_commission(affiliate_commission_id)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except AffiliateCommission.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error deleting affiliate_commission: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
"""Conclusione
Abbiamo completato il servizio e la view per il modello AffiliateCommission. Siamo ora pronti per implementare i successivi modelli, se vuoi procedere ulteriormente!

Fammi sapere se vuoi continuare con il prossimo modello o se hai altre domande.



prosegui
 said:
Perfetto, procediamo con il prossimo modello. Implementiamo il servizio e la view per il modello AffiliateIncentive. Questo modello gestisce gli incentivi per gli affiliati e dovrebbe avere una struttura simile agli altri.

1. Servizio per AffiliateIncentive
Cominciamo con la creazione del servizio che gestisce tutte le operazioni CRUD per AffiliateIncentive.

services/affiliate_incentive_service.py"""
import logging
from typing import List
from affiliate.models.affiliate_incentive import AffiliateIncentive
from affiliate.models.affiliate_program import AffiliateProgram
from affiliate.models.affiliate import Affiliate
from django.contrib.auth import get_user_model

User = get_user_model()

# Set up a logger
logger = logging.getLogger(__name__)

class AffiliateIncentiveService:
    def __init__(self, request=None):
        self.request = request  # Salviamo la request per utilizzarla nei metodi
        self.user = self.request.user if self.request else None

    def get_affiliate_incentive(self) -> List[AffiliateIncentive]:
        try:
            affiliate_incentives = AffiliateIncentive.objects.all()
            self._log_request_info()  # Logga l'informazione della richiesta
            return affiliate_incentives
        except AffiliateIncentive.DoesNotExist:
            logger.warning(f"AffiliateIncentive not found")
            raise ValueError("AffiliateIncentive not found")

    def get_affiliate_incentive_by_id(self, pk) -> AffiliateIncentive:
        try:
            affiliate_incentive = AffiliateIncentive.objects.get(id=pk)
            self._log_request_info()  # Logga l'informazione della richiesta
            return affiliate_incentive
        except AffiliateIncentive.DoesNotExist:
            logger.warning(f"AffiliateIncentive not found: {pk}")
            raise ValueError("AffiliateIncentive not found")

    def create_affiliate_incentive(self, data) -> AffiliateIncentive:
        try:
            affiliate_incentive = AffiliateIncentive(
                affiliate=data.get('affiliate'),
                program=data.get('program'),
                incentive_type=data.get('incentive_type'),
                date=data.get('date'),
                amount=data.get('amount'),
                currency=data.get('currency'),
                status=data.get('status'),
                description=data.get('description'),
                ip_address=data.get('ip_address'),
                device_info=data.get('device_info'),
                tracking_id=data.get('tracking_id'),
                expiration_date=data.get('expiration_date'),
                is_incentive_active=data.get('is_incentive_active')
            )
            affiliate_incentive.save()

            affiliate = Affiliate.objects.get(id=data['affiliate'])
            affiliate_incentive.affiliate = affiliate

            affiliate_program = AffiliateProgram.objects.get(id=data['program'])
            affiliate_incentive.program = affiliate_program

            affiliate_incentive.save()
            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"AffiliateIncentive created: {affiliate_incentive}")
            return affiliate_incentive
        except Exception as e:
            logger.error(f"Error creating affiliate_incentive: {e}")
            raise e

    def update_affiliate_incentive(self, pk, data) -> AffiliateIncentive:
        try:
            affiliate_incentive = self.get_affiliate_incentive_by_id(pk)
            for key, value in data.items():
                setattr(affiliate_incentive, key, value)
            affiliate_incentive.save()
            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"AffiliateIncentive updated: {affiliate_incentive}")
            return affiliate_incentive
        except AffiliateIncentive.DoesNotExist:
            logger.warning(f"AffiliateIncentive not found: {pk}")
            raise ValueError("AffiliateIncentive not found")
        except Exception as e:
            logger.error(f"Error updating affiliate_incentive: {e}")
            raise e

    def delete_affiliate_incentive(self, pk) -> None:
        try:
            affiliate_incentive = self.get_affiliate_incentive_by_id(pk)
            affiliate_incentive.delete()
            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"AffiliateIncentive deleted: {affiliate_incentive}")
        except AffiliateIncentive.DoesNotExist:
            logger.warning(f"AffiliateIncentive not found: {pk}")
            raise ValueError("AffiliateIncentive not found")
        except Exception as e:
            logger.error(f"Error deleting affiliate_incentive: {e}")
            raise e

    def _log_request_info(self):
        """Logga informazioni come IP, User Agent, e cookie se necessario"""
        if self.request:
            user_ip = self.request.META.get('REMOTE_ADDR', 'Unknown')
            user_agent = self.request.META.get('HTTP_USER_AGENT', 'Unknown')
            cookies = self.request.COOKIES
            logger.info(f"Request Info - IP: {user_ip}, User-Agent: {user_agent}, Cookies: {cookies}")
"""2. View per AffiliateIncentive
Ora creiamo la view per AffiliateIncentive che utilizza il servizio per gestire le operazioni CRUD.

views/affiliate_incentive_views.py"""
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from .services.affiliate_incentive_service import AffiliateIncentiveService
from .serializers import AffiliateIncentiveSerializer
from drf_yasg.utils import swagger_auto_schema
from drf_yasg import openapi
from oauth2_provider.contrib.rest_framework import OAuth2Authentication
from rest_framework.permissions import IsAuthenticated

logger = logging.getLogger(__name__)

class AffiliateIncentiveAPIView(APIView):
    permission_classes = [IsAuthenticated]
    authentication_classes = [OAuth2Authentication]

    def __init__(self, *args, **kwargs):
        self.affiliate_incentive_service = AffiliateIncentiveService(request=self.request)  # Passiamo la request al servizio

    @swagger_auto_schema(
        operation_summary="List all affiliate incentives",
        operation_description="Returns a list of all affiliate_incentive entries.",
        responses={200: openapi.Response('Successful Response', AffiliateIncentiveSerializer(many=True))},
        tags=['affiliate_incentive']
    )
    def get(self, request, affiliate_incentive_id=None):
        try:
            if affiliate_incentive_id is None:
                affiliate_incentives = self.affiliate_incentive_service.get_affiliate_incentive()
                return Response(AffiliateIncentiveSerializer(affiliate_incentives, many=True).data, status=status.HTTP_200_OK)
            else:
                affiliate_incentive = self.affiliate_incentive_service.get_affiliate_incentive_by_id(affiliate_incentive_id)
                return Response(AffiliateIncentiveSerializer(affiliate_incentive).data, status=status.HTTP_200_OK)
        except AffiliateIncentive.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error fetching affiliate_incentive: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Create a new affiliate incentive",
        operation_description="Creates a new affiliate_incentive entry.",
        request_body=AffiliateIncentiveSerializer,
        responses={201: openapi.Response('Created', AffiliateIncentiveSerializer)},
        tags=['affiliate_incentive']
    )
    def post(self, request):
        try:
            serializer = AffiliateIncentiveSerializer(data=request.data)
            if serializer.is_valid():
                affiliate_incentive = self.affiliate_incentive_service.create_affiliate_incentive(serializer.validated_data)
                return Response(AffiliateIncentiveSerializer(affiliate_incentive).data, status=status.HTTP_201_CREATED)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            logger.error(f"Error creating affiliate_incentive: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Update an affiliate incentive entry",
        operation_description="Updates a specific affiliate_incentive entry by ID.",
        request_body=AffiliateIncentiveSerializer,
        responses={200: openapi.Response('Successful Response', AffiliateIncentiveSerializer)},
        tags=['affiliate_incentive']
    )
    def put(self, request, affiliate_incentive_id=None):
        try:
            serializer = AffiliateIncentiveSerializer(data=request.data)
            if serializer.is_valid():
                affiliate_incentive = self.affiliate_incentive_service.update_affiliate_incentive(affiliate_incentive_id, serializer.validated_data)
                return Response(AffiliateIncentiveSerializer(affiliate_incentive).data, status=status.HTTP_200_OK)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except AffiliateIncentive.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error updating affiliate_incentive: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Delete an affiliate incentive entry",
        operation_description="Deletes a specific affiliate_incentive entry by ID.",
        responses={204: 'No Content'},
        tags=['affiliate_incentive']
    )
    def delete(self, request, affiliate_incentive_id=None):
        try:
            self.affiliate_incentive_service.delete_affiliate_incentive(affiliate_incentive_id)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except AffiliateIncentive.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error deleting affiliate_incentive: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
"""Conclusione
Abbiamo implementato il servizio e la view per il modello AffiliateIncentive, e siamo pronti per passare al modello successivo. Se vuoi proseguire, fammi sapere!



prosegui
 said:
Perfetto, ora procediamo con il prossimo modello. Implementiamo il servizio e la view per il modello AffiliateTransaction. Questo modello gestisce le transazioni per gli affiliati e seguirà una struttura simile agli altri.

1. Servizio per AffiliateTransaction
Cominciamo con la creazione del servizio che gestisce tutte le operazioni CRUD per AffiliateTransaction.

services/affiliate_transaction_service.py"""
import logging
from typing import List
from affiliate.models.affiliate_transaction import AffiliateTransaction
from affiliate.models.affiliate import Affiliate
from affiliate.models.affiliate_program import AffiliateProgram
from django.contrib.auth import get_user_model

User = get_user_model()

# Set up a logger
logger = logging.getLogger(__name__)

class AffiliateTransactionService:
    def __init__(self, request=None):
        self.request = request  # Salviamo la request per utilizzarla nei metodi
        self.user = self.request.user if self.request else None

    def get_affiliate_transaction(self) -> List[AffiliateTransaction]:
        try:
            affiliate_transactions = AffiliateTransaction.objects.all()
            self._log_request_info()  # Logga l'informazione della richiesta
            return affiliate_transactions
        except AffiliateTransaction.DoesNotExist:
            logger.warning(f"AffiliateTransaction not found")
            raise ValueError("AffiliateTransaction not found")

    def get_affiliate_transaction_by_id(self, pk) -> AffiliateTransaction:
        try:
            affiliate_transaction = AffiliateTransaction.objects.get(id=pk)
            self._log_request_info()  # Logga l'informazione della richiesta
            return affiliate_transaction
        except AffiliateTransaction.DoesNotExist:
            logger.warning(f"AffiliateTransaction not found: {pk}")
            raise ValueError("AffiliateTransaction not found")

    def create_affiliate_transaction(self, data) -> AffiliateTransaction:
        try:
            affiliate_transaction = AffiliateTransaction(
                affiliate=data.get('affiliate'),
                program=data.get('program'),
                transaction_type=data.get('transaction_type'),
                transaction_date=data.get('transaction_date'),
                amount=data.get('amount'),
                currency=data.get('currency'),
                status=data.get('status'),
                description=data.get('description'),
                transaction_id=data.get('transaction_id'),
                tracking_id=data.get('tracking_id'),
                is_successful=data.get('is_successful')
            )
            affiliate_transaction.save()

            affiliate = Affiliate.objects.get(id=data['affiliate'])
            affiliate_transaction.affiliate = affiliate

            affiliate_program = AffiliateProgram.objects.get(id=data['program'])
            affiliate_transaction.program = affiliate_program

            affiliate_transaction.save()
            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"AffiliateTransaction created: {affiliate_transaction}")
            return affiliate_transaction
        except Exception as e:
            logger.error(f"Error creating affiliate_transaction: {e}")
            raise e

    def update_affiliate_transaction(self, pk, data) -> AffiliateTransaction:
        try:
            affiliate_transaction = self.get_affiliate_transaction_by_id(pk)
            for key, value in data.items():
                setattr(affiliate_transaction, key, value)
            affiliate_transaction.save()
            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"AffiliateTransaction updated: {affiliate_transaction}")
            return affiliate_transaction
        except AffiliateTransaction.DoesNotExist:
            logger.warning(f"AffiliateTransaction not found: {pk}")
            raise ValueError("AffiliateTransaction not found")
        except Exception as e:
            logger.error(f"Error updating affiliate_transaction: {e}")
            raise e

    def delete_affiliate_transaction(self, pk) -> None:
        try:
            affiliate_transaction = self.get_affiliate_transaction_by_id(pk)
            affiliate_transaction.delete()
            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"AffiliateTransaction deleted: {affiliate_transaction}")
        except AffiliateTransaction.DoesNotExist:
            logger.warning(f"AffiliateTransaction not found: {pk}")
            raise ValueError("AffiliateTransaction not found")
        except Exception as e:
            logger.error(f"Error deleting affiliate_transaction: {e}")
            raise e

    def _log_request_info(self):
        """Logga informazioni come IP, User Agent, e cookie se necessario"""
        if self.request:
            user_ip = self.request.META.get('REMOTE_ADDR', 'Unknown')
            user_agent = self.request.META.get('HTTP_USER_AGENT', 'Unknown')
            cookies = self.request.COOKIES
            logger.info(f"Request Info - IP: {user_ip}, User-Agent: {user_agent}, Cookies: {cookies}")
"""2. View per AffiliateTransaction
Ora creiamo la view per AffiliateTransaction che utilizza il servizio per gestire le operazioni CRUD.

views/affiliate_transaction_views.py"""
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from .services.affiliate_transaction_service import AffiliateTransactionService
from .serializers import AffiliateTransactionSerializer
from drf_yasg.utils import swagger_auto_schema
from drf_yasg import openapi
from oauth2_provider.contrib.rest_framework import OAuth2Authentication
from rest_framework.permissions import IsAuthenticated

logger = logging.getLogger(__name__)

class AffiliateTransactionAPIView(APIView):
    permission_classes = [IsAuthenticated]
    authentication_classes = [OAuth2Authentication]

    def __init__(self, *args, **kwargs):
        self.affiliate_transaction_service = AffiliateTransactionService(request=self.request)  # Passiamo la request al servizio

    @swagger_auto_schema(
        operation_summary="List all affiliate transactions",
        operation_description="Returns a list of all affiliate_transaction entries.",
        responses={200: openapi.Response('Successful Response', AffiliateTransactionSerializer(many=True))},
        tags=['affiliate_transaction']
    )
    def get(self, request, affiliate_transaction_id=None):
        try:
            if affiliate_transaction_id is None:
                affiliate_transactions = self.affiliate_transaction_service.get_affiliate_transaction()
                return Response(AffiliateTransactionSerializer(affiliate_transactions, many=True).data, status=status.HTTP_200_OK)
            else:
                affiliate_transaction = self.affiliate_transaction_service.get_affiliate_transaction_by_id(affiliate_transaction_id)
                return Response(AffiliateTransactionSerializer(affiliate_transaction).data, status=status.HTTP_200_OK)
        except AffiliateTransaction.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error fetching affiliate_transaction: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Create a new affiliate transaction",
        operation_description="Creates a new affiliate_transaction entry.",
        request_body=AffiliateTransactionSerializer,
        responses={201: openapi.Response('Created', AffiliateTransactionSerializer)},
        tags=['affiliate_transaction']
    )
    def post(self, request):
        try:
            serializer = AffiliateTransactionSerializer(data=request.data)
            if serializer.is_valid():
                affiliate_transaction = self.affiliate_transaction_service.create_affiliate_transaction(serializer.validated_data)
                return Response(AffiliateTransactionSerializer(affiliate_transaction).data, status=status.HTTP_201_CREATED)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            logger.error(f"Error creating affiliate_transaction: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Update an affiliate transaction entry",
        operation_description="Updates a specific affiliate_transaction entry by ID.",
        request_body=AffiliateTransactionSerializer,
        responses={200: openapi.Response('Successful Response', AffiliateTransactionSerializer)},
        tags=['affiliate_transaction']
    )
    def put(self, request, affiliate_transaction_id=None):
        try:
            serializer = AffiliateTransactionSerializer(data=request.data)
            if serializer.is_valid():
                affiliate_transaction = self.affiliate_transaction_service.update_affiliate_transaction(affiliate_transaction_id, serializer.validated_data)
                return Response(AffiliateTransactionSerializer(affiliate_transaction).data, status=status.HTTP_200_OK)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except AffiliateTransaction.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error updating affiliate_transaction: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Delete an affiliate transaction entry",
        operation_description="Deletes a specific affiliate_transaction entry by ID.",
        responses={204: 'No Content'},
        tags=['affiliate_transaction']
    )
    def delete(self, request, affiliate_transaction_id=None):
        try:
            self.affiliate_transaction_service.delete_affiliate_transaction(affiliate_transaction_id)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except AffiliateTransaction.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error deleting affiliate_transaction: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
"""Conclusione
Abbiamo completato l'implementazione del servizio e della view per il modello AffiliateTransaction. Ora siamo pronti per passare al modello successivo, se desideri procedere. Fammi sapere!



prosegui
 said:
Perfetto! Ora proseguiamo con il modello successivo: AffiliateCommission. Implementiamo il servizio e la view per questo modello.

1. Servizio per AffiliateCommission
Cominceremo con il servizio per gestire le operazioni CRUD relative alle commissioni degli affiliati.

services/affiliate_commission_service.py"""
import logging
from typing import List
from affiliate.models.affiliate_commission import AffiliateCommission
from affiliate.models.affiliate import Affiliate
from affiliate.models.affiliate_program import AffiliateProgram
from django.contrib.auth import get_user_model

User = get_user_model()

# Set up a logger
logger = logging.getLogger(__name__)

class AffiliateCommissionService:
    def __init__(self, request=None):
        self.request = request  # Salviamo la request per utilizzarla nei metodi
        self.user = self.request.user if self.request else None

    def get_affiliate_commissions(self) -> List[AffiliateCommission]:
        try:
            affiliate_commissions = AffiliateCommission.objects.all()
            self._log_request_info()  # Logga l'informazione della richiesta
            return affiliate_commissions
        except AffiliateCommission.DoesNotExist:
            logger.warning(f"AffiliateCommission not found")
            raise ValueError("AffiliateCommission not found")

    def get_affiliate_commission_by_id(self, pk) -> AffiliateCommission:
        try:
            affiliate_commission = AffiliateCommission.objects.get(id=pk)
            self._log_request_info()  # Logga l'informazione della richiesta
            return affiliate_commission
        except AffiliateCommission.DoesNotExist:
            logger.warning(f"AffiliateCommission not found: {pk}")
            raise ValueError("AffiliateCommission not found")

    def create_affiliate_commission(self, data) -> AffiliateCommission:
        try:
            affiliate_commission = AffiliateCommission(
                affiliate=data.get('affiliate'),
                program=data.get('program'),
                amount=data.get('amount'),
                currency=data.get('currency'),
                date_awarded=data.get('date_awarded'),
                status=data.get('status'),
                approved_by=data.get('approved_by'),
                commission_type=data.get('commission_type'),
                description=data.get('description'),
                tier=data.get('tier')
            )
            affiliate_commission.save()

            affiliate = Affiliate.objects.get(id=data['affiliate'])
            affiliate_commission.affiliate = affiliate

            affiliate_program = AffiliateProgram.objects.get(id=data['program'])
            affiliate_commission.program = affiliate_program

            affiliate_commission.save()
            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"AffiliateCommission created: {affiliate_commission}")
            return affiliate_commission
        except Exception as e:
            logger.error(f"Error creating affiliate_commission: {e}")
            raise e

    def update_affiliate_commission(self, pk, data) -> AffiliateCommission:
        try:
            affiliate_commission = self.get_affiliate_commission_by_id(pk)
            for key, value in data.items():
                setattr(affiliate_commission, key, value)
            affiliate_commission.save()
            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"AffiliateCommission updated: {affiliate_commission}")
            return affiliate_commission
        except AffiliateCommission.DoesNotExist:
            logger.warning(f"AffiliateCommission not found: {pk}")
            raise ValueError("AffiliateCommission not found")
        except Exception as e:
            logger.error(f"Error updating affiliate_commission: {e}")
            raise e

    def delete_affiliate_commission(self, pk) -> None:
        try:
            affiliate_commission = self.get_affiliate_commission_by_id(pk)
            affiliate_commission.delete()
            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"AffiliateCommission deleted: {affiliate_commission}")
        except AffiliateCommission.DoesNotExist:
            logger.warning(f"AffiliateCommission not found: {pk}")
            raise ValueError("AffiliateCommission not found")
        except Exception as e:
            logger.error(f"Error deleting affiliate_commission: {e}")
            raise e

    def _log_request_info(self):
        """Logga informazioni come IP, User Agent, e cookie se necessario"""
        if self.request:
            user_ip = self.request.META.get('REMOTE_ADDR', 'Unknown')
            user_agent = self.request.META.get('HTTP_USER_AGENT', 'Unknown')
            cookies = self.request.COOKIES
            logger.info(f"Request Info - IP: {user_ip}, User-Agent: {user_agent}, Cookies: {cookies}")
"""2. View per AffiliateCommission
Ora implementiamo la view per AffiliateCommission, che si interfaccia con il servizio per gestire tutte le operazioni.

views/affiliate_commission_views.py"""
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from .services.affiliate_commission_service import AffiliateCommissionService
from .serializers import AffiliateCommissionSerializer
from drf_yasg.utils import swagger_auto_schema
from drf_yasg import openapi
from oauth2_provider.contrib.rest_framework import OAuth2Authentication
from rest_framework.permissions import IsAuthenticated

logger = logging.getLogger(__name__)

class AffiliateCommissionAPIView(APIView):
    permission_classes = [IsAuthenticated]
    authentication_classes = [OAuth2Authentication]

    def __init__(self, *args, **kwargs):
        self.affiliate_commission_service = AffiliateCommissionService(request=self.request)  # Passiamo la request al servizio

    @swagger_auto_schema(
        operation_summary="List all affiliate commissions",
        operation_description="Returns a list of all affiliate_commission entries.",
        responses={200: openapi.Response('Successful Response', AffiliateCommissionSerializer(many=True))},
        tags=['affiliate_commission']
    )
    def get(self, request, affiliate_commission_id=None):
        try:
            if affiliate_commission_id is None:
                affiliate_commissions = self.affiliate_commission_service.get_affiliate_commissions()
                return Response(AffiliateCommissionSerializer(affiliate_commissions, many=True).data, status=status.HTTP_200_OK)
            else:
                affiliate_commission = self.affiliate_commission_service.get_affiliate_commission_by_id(affiliate_commission_id)
                return Response(AffiliateCommissionSerializer(affiliate_commission).data, status=status.HTTP_200_OK)
        except AffiliateCommission.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error fetching affiliate_commission: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Create a new affiliate commission",
        operation_description="Creates a new affiliate_commission entry.",
        request_body=AffiliateCommissionSerializer,
        responses={201: openapi.Response('Created', AffiliateCommissionSerializer)},
        tags=['affiliate_commission']
    )
    def post(self, request):
        try:
            serializer = AffiliateCommissionSerializer(data=request.data)
            if serializer.is_valid():
                affiliate_commission = self.affiliate_commission_service.create_affiliate_commission(serializer.validated_data)
                return Response(AffiliateCommissionSerializer(affiliate_commission).data, status=status.HTTP_201_CREATED)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            logger.error(f"Error creating affiliate_commission: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Update an affiliate commission entry",
        operation_description="Updates a specific affiliate_commission entry by ID.",
        request_body=AffiliateCommissionSerializer,
        responses={200: openapi.Response('Successful Response', AffiliateCommissionSerializer)},
        tags=['affiliate_commission']
    )
    def put(self, request, affiliate_commission_id=None):
        try:
            serializer = AffiliateCommissionSerializer(data=request.data)
            if serializer.is_valid():
                affiliate_commission = self.affiliate_commission_service.update_affiliate_commission(affiliate_commission_id, serializer.validated_data)
                return Response(AffiliateCommissionSerializer(affiliate_commission).data, status=status.HTTP_200_OK)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except AffiliateCommission.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error updating affiliate_commission: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Delete an affiliate commission entry",
        operation_description="Deletes a specific affiliate_commission entry by ID.",
        responses={204: 'No Content'},
        tags=['affiliate_commission']
    )
    def delete(self, request, affiliate_commission_id=None):
        try:
            self.affiliate_commission_service.delete_affiliate_commission(affiliate_commission_id)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except AffiliateCommission.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error deleting affiliate_commission: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
"""Conclusione
Abbiamo completato l'implementazione del servizio e della view per il modello AffiliateCommission. Se vuoi proseguire, fammi sapere!



prosegui
 said:
Perfetto, ora procediamo con il modello successivo: AffiliateIncentive. Implementiamo il servizio e la view per questo modello.

1. Servizio per AffiliateIncentive
Cominceremo con il servizio per gestire le operazioni CRUD relative agli incentivi degli affiliati.

services/affiliate_incentive_service.py"""
import logging
from typing import List
from affiliate.models.affiliate_incentive import AffiliateIncentive
from affiliate.models.affiliate import Affiliate
from affiliate.models.affiliate_program import AffiliateProgram
from django.contrib.auth import get_user_model

User = get_user_model()

# Set up a logger
logger = logging.getLogger(__name__)

class AffiliateIncentiveService:
    def __init__(self, request=None):
        self.request = request  # Salviamo la request per utilizzarla nei metodi
        self.user = self.request.user if self.request else None

    def get_affiliate_incentives(self) -> List[AffiliateIncentive]:
        try:
            affiliate_incentives = AffiliateIncentive.objects.all()
            self._log_request_info()  # Logga l'informazione della richiesta
            return affiliate_incentives
        except AffiliateIncentive.DoesNotExist:
            logger.warning(f"AffiliateIncentive not found")
            raise ValueError("AffiliateIncentive not found")

    def get_affiliate_incentive_by_id(self, pk) -> AffiliateIncentive:
        try:
            affiliate_incentive = AffiliateIncentive.objects.get(id=pk)
            self._log_request_info()  # Logga l'informazione della richiesta
            return affiliate_incentive
        except AffiliateIncentive.DoesNotExist:
            logger.warning(f"AffiliateIncentive not found: {pk}")
            raise ValueError("AffiliateIncentive not found")

    def create_affiliate_incentive(self, data) -> AffiliateIncentive:
        try:
            affiliate_incentive = AffiliateIncentive(
                affiliate=data.get('affiliate'),
                program=data.get('program'),
                incentive_type=data.get('incentive_type'),
                date=data.get('date'),
                amount=data.get('amount'),
                currency=data.get('currency'),
                status=data.get('status'),
                description=data.get('description'),
                ip_address=data.get('ip_address'),
                device_info=data.get('device_info'),
                tracking_id=data.get('tracking_id'),
                expiration_date=data.get('expiration_date'),
                is_incentive_active=data.get('is_incentive_active')
            )
            affiliate_incentive.save()

            affiliate = Affiliate.objects.get(id=data['affiliate'])
            affiliate_incentive.affiliate = affiliate

            affiliate_program = AffiliateProgram.objects.get(id=data['program'])
            affiliate_incentive.program = affiliate_program

            affiliate_incentive.save()
            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"AffiliateIncentive created: {affiliate_incentive}")
            return affiliate_incentive
        except Exception as e:
            logger.error(f"Error creating affiliate_incentive: {e}")
            raise e

    def update_affiliate_incentive(self, pk, data) -> AffiliateIncentive:
        try:
            affiliate_incentive = self.get_affiliate_incentive_by_id(pk)
            for key, value in data.items():
                setattr(affiliate_incentive, key, value)
            affiliate_incentive.save()
            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"AffiliateIncentive updated: {affiliate_incentive}")
            return affiliate_incentive
        except AffiliateIncentive.DoesNotExist:
            logger.warning(f"AffiliateIncentive not found: {pk}")
            raise ValueError("AffiliateIncentive not found")
        except Exception as e:
            logger.error(f"Error updating affiliate_incentive: {e}")
            raise e

    def delete_affiliate_incentive(self, pk) -> None:
        try:
            affiliate_incentive = self.get_affiliate_incentive_by_id(pk)
            affiliate_incentive.delete()
            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"AffiliateIncentive deleted: {affiliate_incentive}")
        except AffiliateIncentive.DoesNotExist:
            logger.warning(f"AffiliateIncentive not found: {pk}")
            raise ValueError("AffiliateIncentive not found")
        except Exception as e:
            logger.error(f"Error deleting affiliate_incentive: {e}")
            raise e

    def _log_request_info(self):
        """Logga informazioni come IP, User Agent, e cookie se necessario"""
        if self.request:
            user_ip = self.request.META.get('REMOTE_ADDR', 'Unknown')
            user_agent = self.request.META.get('HTTP_USER_AGENT', 'Unknown')
            cookies = self.request.COOKIES
            logger.info(f"Request Info - IP: {user_ip}, User-Agent: {user_agent}, Cookies: {cookies}")
"""2. View per AffiliateIncentive
Ora implementiamo la view per AffiliateIncentive, che si interfaccia con il servizio per gestire tutte le operazioni.

views/affiliate_incentive_views.py"""
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from .services.affiliate_incentive_service import AffiliateIncentiveService
from .serializers import AffiliateIncentiveSerializer
from drf_yasg.utils import swagger_auto_schema
from drf_yasg import openapi
from oauth2_provider.contrib.rest_framework import OAuth2Authentication
from rest_framework.permissions import IsAuthenticated

logger = logging.getLogger(__name__)

class AffiliateIncentiveAPIView(APIView):
    permission_classes = [IsAuthenticated]
    authentication_classes = [OAuth2Authentication]

    def __init__(self, *args, **kwargs):
        self.affiliate_incentive_service = AffiliateIncentiveService(request=self.request)  # Passiamo la request al servizio

    @swagger_auto_schema(
        operation_summary="List all affiliate incentives",
        operation_description="Returns a list of all affiliate_incentive entries.",
        responses={200: openapi.Response('Successful Response', AffiliateIncentiveSerializer(many=True))},
        tags=['affiliate_incentive']
    )
    def get(self, request, affiliate_incentive_id=None):
        try:
            if affiliate_incentive_id is None:
                affiliate_incentives = self.affiliate_incentive_service.get_affiliate_incentives()
                return Response(AffiliateIncentiveSerializer(affiliate_incentives, many=True).data, status=status.HTTP_200_OK)
            else:
                affiliate_incentive = self.affiliate_incentive_service.get_affiliate_incentive_by_id(affiliate_incentive_id)
                return Response(AffiliateIncentiveSerializer(affiliate_incentive).data, status=status.HTTP_200_OK)
        except AffiliateIncentive.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error fetching affiliate_incentive: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Create a new affiliate incentive",
        operation_description="Creates a new affiliate_incentive entry.",
        request_body=AffiliateIncentiveSerializer,
        responses={201: openapi.Response('Created', AffiliateIncentiveSerializer)},
        tags=['affiliate_incentive']
    )
    def post(self, request):
        try:
            serializer = AffiliateIncentiveSerializer(data=request.data)
            if serializer.is_valid():
                affiliate_incentive = self.affiliate_incentive_service.create_affiliate_incentive(serializer.validated_data)
                return Response(AffiliateIncentiveSerializer(affiliate_incentive).data, status=status.HTTP_201_CREATED)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            logger.error(f"Error creating affiliate_incentive: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Update an affiliate incentive entry",
        operation_description="Updates a specific affiliate_incentive entry by ID.",
        request_body=AffiliateIncentiveSerializer,
        responses={200: openapi.Response('Successful Response', AffiliateIncentiveSerializer)},
        tags=['affiliate_incentive']
    )
    def put(self, request, affiliate_incentive_id=None):
        try:
            serializer = AffiliateIncentiveSerializer(data=request.data)
            if serializer.is_valid():
                affiliate_incentive = self.affiliate_incentive_service.update_affiliate_incentive(affiliate_incentive_id, serializer.validated_data)
                return Response(AffiliateIncentiveSerializer(affiliate_incentive).data, status=status.HTTP_200_OK)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except AffiliateIncentive.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error updating affiliate_incentive: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Delete an affiliate incentive entry",
        operation_description="Deletes a specific affiliate_incentive entry by ID.",
        responses={204: 'No Content'},
        tags=['affiliate_incentive']
    )
    def delete(self, request, affiliate_incentive_id=None):
        try:
            self.affiliate_incentive_service.delete_affiliate_incentive(affiliate_incentive_id)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except AffiliateIncentive.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error deleting affiliate_incentive: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
"""Conclusione
Abbiamo completato l'implementazione del servizio e della view per il modello AffiliateIncentive. Se vuoi proseguire con altri modelli, fammi sapere!



Hai fatto:
referral_bonus
affiliate_bonus
affiliate_commission
affiliate_incentive
affiliate_transaction
affiliate_commission


Ricorda che nel completo le entità sono:
affiliate_audit
affiliate_campaign
affiliate_commission
affiliate_incentive
affiliate_link
affiliate_notification
affiliate_payout
affiliate_performance
affiliate_program_partecipation
affiliate_program
affiliate_reward
affiliate_settings
affiliate_support_ticket
affiliate_tier
affiliate_transaction
affiliate.py


referral_audit
referral_bonus
referral_campaign
referral_code
referral_conversion
referral_engagement
referral_level
referral_notification
referral_program_partecipation
referral_program
referral_reward
referral_settings
referral_stats
referral_transaction
referral_user
referral.py
 said:
Perfetto, vedo che ci sono altre entità che dobbiamo implementare. Procederò ad implementare i servizi e le views per ciascuna delle entità restanti. Poiché la tua richiesta riguarda una serie di modelli, possiamo procedere passo per passo.

Comincerò a implementare i servizi e le views per le entità mancanti e ti aggiornerò ogni volta che termino una. Continuiamo con il modello AffiliateAudit:

1. Servizio per AffiliateAudit
Iniziamo con il servizio per gestire le operazioni CRUD relative agli audit degli affiliati.

services/affiliate_audit_service.py
"""
import logging
from typing import List
from affiliate.models.affiliate_audit import AffiliateAudit
from django.contrib.auth import get_user_model

User = get_user_model()

# Set up a logger
logger = logging.getLogger(__name__)

class AffiliateAuditService:
    def __init__(self, request=None):
        self.request = request
        self.user = self.request.user if self.request else None

    def get_affiliate_audits(self) -> List[AffiliateAudit]:
        try:
            affiliate_audits = AffiliateAudit.objects.all()
            self._log_request_info()  # Logga l'informazione della richiesta
            return affiliate_audits
        except AffiliateAudit.DoesNotExist:
            logger.warning(f"AffiliateAudit not found")
            raise ValueError("AffiliateAudit not found")

    def get_affiliate_audit_by_id(self, pk) -> AffiliateAudit:
        try:
            affiliate_audit = AffiliateAudit.objects.get(id=pk)
            self._log_request_info()  # Logga l'informazione della richiesta
            return affiliate_audit
        except AffiliateAudit.DoesNotExist:
            logger.warning(f"AffiliateAudit not found: {pk}")
            raise ValueError("AffiliateAudit not found")

    def create_affiliate_audit(self, data) -> AffiliateAudit:
        try:
            affiliate_audit = AffiliateAudit(
                affiliate=data.get('affiliate'),
                action=data.get('action'),
                description=data.get('description'),
                timestamp=data.get('timestamp'),
                ip_address=data.get('ip_address'),
                user_agent=data.get('user_agent')
            )
            affiliate_audit.save()
            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"AffiliateAudit created: {affiliate_audit}")
            return affiliate_audit
        except Exception as e:
            logger.error(f"Error creating affiliate_audit: {e}")
            raise e

    def update_affiliate_audit(self, pk, data) -> AffiliateAudit:
        try:
            affiliate_audit = self.get_affiliate_audit_by_id(pk)
            for key, value in data.items():
                setattr(affiliate_audit, key, value)
            affiliate_audit.save()
            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"AffiliateAudit updated: {affiliate_audit}")
            return affiliate_audit
        except AffiliateAudit.DoesNotExist:
            logger.warning(f"AffiliateAudit not found: {pk}")
            raise ValueError("AffiliateAudit not found")
        except Exception as e:
            logger.error(f"Error updating affiliate_audit: {e}")
            raise e

    def delete_affiliate_audit(self, pk) -> None:
        try:
            affiliate_audit = self.get_affiliate_audit_by_id(pk)
            affiliate_audit.delete()
            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"AffiliateAudit deleted: {affiliate_audit}")
        except AffiliateAudit.DoesNotExist:
            logger.warning(f"AffiliateAudit not found: {pk}")
            raise ValueError("AffiliateAudit not found")
        except Exception as e:
            logger.error(f"Error deleting affiliate_audit: {e}")
            raise e

    def _log_request_info(self):
        """Logga informazioni come IP, User Agent, e cookie se necessario"""
        if self.request:
            user_ip = self.request.META.get('REMOTE_ADDR', 'Unknown')
            user_agent = self.request.META.get('HTTP_USER_AGENT', 'Unknown')
            cookies = self.request.COOKIES
            logger.info(f"Request Info - IP: {user_ip}, User-Agent: {user_agent}, Cookies: {cookies}")
"""2. View per AffiliateAudit
Ora implementiamo la view per AffiliateAudit, che interagirà con il servizio per gestire le operazioni.

views/affiliate_audit_views.py"""
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from .services.affiliate_audit_service import AffiliateAuditService
from .serializers import AffiliateAuditSerializer
from drf_yasg.utils import swagger_auto_schema
from drf_yasg import openapi
from oauth2_provider.contrib.rest_framework import OAuth2Authentication
from rest_framework.permissions import IsAuthenticated

logger = logging.getLogger(__name__)

class AffiliateAuditAPIView(APIView):
    permission_classes = [IsAuthenticated]
    authentication_classes = [OAuth2Authentication]

    def __init__(self, *args, **kwargs):
        self.affiliate_audit_service = AffiliateAuditService(request=self.request)

    @swagger_auto_schema(
        operation_summary="List all affiliate audits",
        operation_description="Returns a list of all affiliate_audit entries.",
        responses={200: openapi.Response('Successful Response', AffiliateAuditSerializer(many=True))},
        tags=['affiliate_audit']
    )
    def get(self, request, affiliate_audit_id=None):
        try:
            if affiliate_audit_id is None:
                affiliate_audits = self.affiliate_audit_service.get_affiliate_audits()
                return Response(AffiliateAuditSerializer(affiliate_audits, many=True).data, status=status.HTTP_200_OK)
            else:
                affiliate_audit = self.affiliate_audit_service.get_affiliate_audit_by_id(affiliate_audit_id)
                return Response(AffiliateAuditSerializer(affiliate_audit).data, status=status.HTTP_200_OK)
        except AffiliateAudit.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error fetching affiliate_audit: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Create a new affiliate audit",
        operation_description="Creates a new affiliate_audit entry.",
        request_body=AffiliateAuditSerializer,
        responses={201: openapi.Response('Created', AffiliateAuditSerializer)},
        tags=['affiliate_audit']
    )
    def post(self, request):
        try:
            serializer = AffiliateAuditSerializer(data=request.data)
            if serializer.is_valid():
                affiliate_audit = self.affiliate_audit_service.create_affiliate_audit(serializer.validated_data)
                return Response(AffiliateAuditSerializer(affiliate_audit).data, status=status.HTTP_201_CREATED)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            logger.error(f"Error creating affiliate_audit: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Update an affiliate audit entry",
        operation_description="Updates a specific affiliate_audit entry by ID.",
        request_body=AffiliateAuditSerializer,
        responses={200: openapi.Response('Successful Response', AffiliateAuditSerializer)},
        tags=['affiliate_audit']
    )
    def put(self, request, affiliate_audit_id=None):
        try:
            serializer = AffiliateAuditSerializer(data=request.data)
            if serializer.is_valid():
                affiliate_audit = self.affiliate_audit_service.update_affiliate_audit(affiliate_audit_id, serializer.validated_data)
                return Response(AffiliateAuditSerializer(affiliate_audit).data, status=status.HTTP_200_OK)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except AffiliateAudit.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error updating affiliate_audit: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Delete an affiliate audit entry",
        operation_description="Deletes a specific affiliate_audit entry by ID.",
        responses={204: 'No Content'},
        tags=['affiliate_audit']
    )
    def delete(self, request, affiliate_audit_id=None):
        try:
            self.affiliate_audit_service.delete_affiliate_audit(affiliate_audit_id)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except AffiliateAudit.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error deleting affiliate_audit: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
"""Conclusione
Abbiamo completato l'implementazione del servizio e della view per il modello AffiliateAudit. Se desideri proseguire con altre entità, fammi sapere e procederò con quelle!



si procedi
 said:
Perfetto! Continuiamo con l'implementazione del servizio e della view per la prossima entità: AffiliateCampaign.

1. Servizio per AffiliateCampaign
services/affiliate_campaign_service.py"""
import logging
from typing import List
from affiliate.models.affiliate_campaign import AffiliateCampaign

# Set up a logger
logger = logging.getLogger(__name__)

class AffiliateCampaignService:
    def __init__(self, request=None):
        self.request = request
        self.user = self.request.user if self.request else None

    def get_affiliate_campaigns(self) -> List[AffiliateCampaign]:
        try:
            affiliate_campaigns = AffiliateCampaign.objects.all()
            self._log_request_info()  # Logga l'informazione della richiesta
            return affiliate_campaigns
        except AffiliateCampaign.DoesNotExist:
            logger.warning(f"AffiliateCampaign not found")
            raise ValueError("AffiliateCampaign not found")

    def get_affiliate_campaign_by_id(self, pk) -> AffiliateCampaign:
        try:
            affiliate_campaign = AffiliateCampaign.objects.get(id=pk)
            self._log_request_info()  # Logga l'informazione della richiesta
            return affiliate_campaign
        except AffiliateCampaign.DoesNotExist:
            logger.warning(f"AffiliateCampaign not found: {pk}")
            raise ValueError("AffiliateCampaign not found")

    def create_affiliate_campaign(self, data) -> AffiliateCampaign:
        try:
            affiliate_campaign = AffiliateCampaign(
                name=data.get('name'),
                description=data.get('description'),
                start_date=data.get('start_date'),
                end_date=data.get('end_date'),
                budget=data.get('budget'),
                status=data.get('status')
            )
            affiliate_campaign.save()
            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"AffiliateCampaign created: {affiliate_campaign}")
            return affiliate_campaign
        except Exception as e:
            logger.error(f"Error creating affiliate_campaign: {e}")
            raise e

    def update_affiliate_campaign(self, pk, data) -> AffiliateCampaign:
        try:
            affiliate_campaign = self.get_affiliate_campaign_by_id(pk)
            for key, value in data.items():
                setattr(affiliate_campaign, key, value)
            affiliate_campaign.save()
            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"AffiliateCampaign updated: {affiliate_campaign}")
            return affiliate_campaign
        except AffiliateCampaign.DoesNotExist:
            logger.warning(f"AffiliateCampaign not found: {pk}")
            raise ValueError("AffiliateCampaign not found")
        except Exception as e:
            logger.error(f"Error updating affiliate_campaign: {e}")
            raise e

    def delete_affiliate_campaign(self, pk) -> None:
        try:
            affiliate_campaign = self.get_affiliate_campaign_by_id(pk)
            affiliate_campaign.delete()
            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"AffiliateCampaign deleted: {affiliate_campaign}")
        except AffiliateCampaign.DoesNotExist:
            logger.warning(f"AffiliateCampaign not found: {pk}")
            raise ValueError("AffiliateCampaign not found")
        except Exception as e:
            logger.error(f"Error deleting affiliate_campaign: {e}")
            raise e

    def _log_request_info(self):
        """Logga informazioni come IP, User Agent, e cookie se necessario"""
        if self.request:
            user_ip = self.request.META.get('REMOTE_ADDR', 'Unknown')
            user_agent = self.request.META.get('HTTP_USER_AGENT', 'Unknown')
            cookies = self.request.COOKIES
            logger.info(f"Request Info - IP: {user_ip}, User-Agent: {user_agent}, Cookies: {cookies}")
"""2. View per AffiliateCampaign
views/affiliate_campaign_views.py"""
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from .services.affiliate_campaign_service import AffiliateCampaignService
from .serializers import AffiliateCampaignSerializer
from drf_yasg.utils import swagger_auto_schema
from drf_yasg import openapi
from oauth2_provider.contrib.rest_framework import OAuth2Authentication
from rest_framework.permissions import IsAuthenticated

logger = logging.getLogger(__name__)

class AffiliateCampaignAPIView(APIView):
    permission_classes = [IsAuthenticated]
    authentication_classes = [OAuth2Authentication]

    def __init__(self, *args, **kwargs):
        self.affiliate_campaign_service = AffiliateCampaignService(request=self.request)

    @swagger_auto_schema(
        operation_summary="List all affiliate campaigns",
        operation_description="Returns a list of all affiliate_campaign entries.",
        responses={200: openapi.Response('Successful Response', AffiliateCampaignSerializer(many=True))},
        tags=['affiliate_campaign']
    )
    def get(self, request, affiliate_campaign_id=None):
        try:
            if affiliate_campaign_id is None:
                affiliate_campaigns = self.affiliate_campaign_service.get_affiliate_campaigns()
                return Response(AffiliateCampaignSerializer(affiliate_campaigns, many=True).data, status=status.HTTP_200_OK)
            else:
                affiliate_campaign = self.affiliate_campaign_service.get_affiliate_campaign_by_id(affiliate_campaign_id)
                return Response(AffiliateCampaignSerializer(affiliate_campaign).data, status=status.HTTP_200_OK)
        except AffiliateCampaign.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error fetching affiliate_campaign: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Create a new affiliate campaign",
        operation_description="Creates a new affiliate_campaign entry.",
        request_body=AffiliateCampaignSerializer,
        responses={201: openapi.Response('Created', AffiliateCampaignSerializer)},
        tags=['affiliate_campaign']
    )
    def post(self, request):
        try:
            serializer = AffiliateCampaignSerializer(data=request.data)
            if serializer.is_valid():
                affiliate_campaign = self.affiliate_campaign_service.create_affiliate_campaign(serializer.validated_data)
                return Response(AffiliateCampaignSerializer(affiliate_campaign).data, status=status.HTTP_201_CREATED)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            logger.error(f"Error creating affiliate_campaign: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Update an affiliate campaign entry",
        operation_description="Updates a specific affiliate_campaign entry by ID.",
        request_body=AffiliateCampaignSerializer,
        responses={200: openapi.Response('Successful Response', AffiliateCampaignSerializer)},
        tags=['affiliate_campaign']
    )
    def put(self, request, affiliate_campaign_id=None):
        try:
            serializer = AffiliateCampaignSerializer(data=request.data)
            if serializer.is_valid():
                affiliate_campaign = self.affiliate_campaign_service.update_affiliate_campaign(affiliate_campaign_id, serializer.validated_data)
                return Response(AffiliateCampaignSerializer(affiliate_campaign).data, status=status.HTTP_200_OK)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except AffiliateCampaign.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error updating affiliate_campaign: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Delete an affiliate campaign entry",
        operation_description="Deletes a specific affiliate_campaign entry by ID.",
        responses={204: 'No Content'},
        tags=['affiliate_campaign']
    )
    def delete(self, request, affiliate_campaign_id=None):
        try:
            self.affiliate_campaign_service.delete_affiliate_campaign(affiliate_campaign_id)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except AffiliateCampaign.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error deleting affiliate_campaign: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
"""Conclusione
Abbiamo implementato il servizio e la view per AffiliateCampaign. Se sei pronto a proseguire, fammi sapere e continuerò con l'implementazione delle entità successive!



continua pure
 said:
Perfetto, continuiamo con l'implementazione del servizio e della view per la prossima entità: AffiliateLink.

1. Servizio per AffiliateLink
services/affiliate_link_service.py"""
import logging
from typing import List
from affiliate.models.affiliate_link import AffiliateLink

# Set up a logger
logger = logging.getLogger(__name__)

class AffiliateLinkService:
    def __init__(self, request=None):
        self.request = request
        self.user = self.request.user if self.request else None

    def get_affiliate_links(self) -> List[AffiliateLink]:
        try:
            affiliate_links = AffiliateLink.objects.all()
            self._log_request_info()  # Logga l'informazione della richiesta
            return affiliate_links
        except AffiliateLink.DoesNotExist:
            logger.warning(f"AffiliateLink not found")
            raise ValueError("AffiliateLink not found")

    def get_affiliate_link_by_id(self, pk) -> AffiliateLink:
        try:
            affiliate_link = AffiliateLink.objects.get(id=pk)
            self._log_request_info()  # Logga l'informazione della richiesta
            return affiliate_link
        except AffiliateLink.DoesNotExist:
            logger.warning(f"AffiliateLink not found: {pk}")
            raise ValueError("AffiliateLink not found")

    def create_affiliate_link(self, data) -> AffiliateLink:
        try:
            affiliate_link = AffiliateLink(
                url=data.get('url'),
                click_count=data.get('click_count', 0),
                conversion_count=data.get('conversion_count', 0),
                date_created=data.get('date_created'),
                last_used=data.get('last_used'),
                link_status=data.get('link_status'),
                landing_page=data.get('landing_page'),
                custom_tracking_id=data.get('custom_tracking_id')
            )
            affiliate_link.save()
            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"AffiliateLink created: {affiliate_link}")
            return affiliate_link
        except Exception as e:
            logger.error(f"Error creating affiliate_link: {e}")
            raise e

    def update_affiliate_link(self, pk, data) -> AffiliateLink:
        try:
            affiliate_link = self.get_affiliate_link_by_id(pk)
            for key, value in data.items():
                setattr(affiliate_link, key, value)
            affiliate_link.save()
            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"AffiliateLink updated: {affiliate_link}")
            return affiliate_link
        except AffiliateLink.DoesNotExist:
            logger.warning(f"AffiliateLink not found: {pk}")
            raise ValueError("AffiliateLink not found")
        except Exception as e:
            logger.error(f"Error updating affiliate_link: {e}")
            raise e

    def delete_affiliate_link(self, pk) -> None:
        try:
            affiliate_link = self.get_affiliate_link_by_id(pk)
            affiliate_link.delete()
            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"AffiliateLink deleted: {affiliate_link}")
        except AffiliateLink.DoesNotExist:
            logger.warning(f"AffiliateLink not found: {pk}")
            raise ValueError("AffiliateLink not found")
        except Exception as e:
            logger.error(f"Error deleting affiliate_link: {e}")
            raise e

    def _log_request_info(self):
        """Logga informazioni come IP, User Agent, e cookie se necessario"""
        if self.request:
            user_ip = self.request.META.get('REMOTE_ADDR', 'Unknown')
            user_agent = self.request.META.get('HTTP_USER_AGENT', 'Unknown')
            cookies = self.request.COOKIES
            logger.info(f"Request Info - IP: {user_ip}, User-Agent: {user_agent}, Cookies: {cookies}")
"""2. View per AffiliateLink
views/affiliate_link_views.py"""
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from .services.affiliate_link_service import AffiliateLinkService
from .serializers import AffiliateLinkSerializer
from drf_yasg.utils import swagger_auto_schema
from drf_yasg import openapi
from oauth2_provider.contrib.rest_framework import OAuth2Authentication
from rest_framework.permissions import IsAuthenticated

logger = logging.getLogger(__name__)

class AffiliateLinkAPIView(APIView):
    permission_classes = [IsAuthenticated]
    authentication_classes = [OAuth2Authentication]

    def __init__(self, *args, **kwargs):
        self.affiliate_link_service = AffiliateLinkService(request=self.request)

    @swagger_auto_schema(
        operation_summary="List all affiliate links",
        operation_description="Returns a list of all affiliate_link entries.",
        responses={200: openapi.Response('Successful Response', AffiliateLinkSerializer(many=True))},
        tags=['affiliate_link']
    )
    def get(self, request, affiliate_link_id=None):
        try:
            if affiliate_link_id is None:
                affiliate_links = self.affiliate_link_service.get_affiliate_links()
                return Response(AffiliateLinkSerializer(affiliate_links, many=True).data, status=status.HTTP_200_OK)
            else:
                affiliate_link = self.affiliate_link_service.get_affiliate_link_by_id(affiliate_link_id)
                return Response(AffiliateLinkSerializer(affiliate_link).data, status=status.HTTP_200_OK)
        except AffiliateLink.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error fetching affiliate_link: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Create a new affiliate link",
        operation_description="Creates a new affiliate_link entry.",
        request_body=AffiliateLinkSerializer,
        responses={201: openapi.Response('Created', AffiliateLinkSerializer)},
        tags=['affiliate_link']
    )
    def post(self, request):
        try:
            serializer = AffiliateLinkSerializer(data=request.data)
            if serializer.is_valid():
                affiliate_link = self.affiliate_link_service.create_affiliate_link(serializer.validated_data)
                return Response(AffiliateLinkSerializer(affiliate_link).data, status=status.HTTP_201_CREATED)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            logger.error(f"Error creating affiliate_link: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Update an affiliate link entry",
        operation_description="Updates a specific affiliate_link entry by ID.",
        request_body=AffiliateLinkSerializer,
        responses={200: openapi.Response('Successful Response', AffiliateLinkSerializer)},
        tags=['affiliate_link']
    )
    def put(self, request, affiliate_link_id=None):
        try:
            serializer = AffiliateLinkSerializer(data=request.data)
            if serializer.is_valid():
                affiliate_link = self.affiliate_link_service.update_affiliate_link(affiliate_link_id, serializer.validated_data)
                return Response(AffiliateLinkSerializer(affiliate_link).data, status=status.HTTP_200_OK)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except AffiliateLink.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error updating affiliate_link: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Delete an affiliate link entry",
        operation_description="Deletes a specific affiliate_link entry by ID.",
        responses={204: 'No Content'},
        tags=['affiliate_link']
    )
    def delete(self, request, affiliate_link_id=None):
        try:
            self.affiliate_link_service.delete_affiliate_link(affiliate_link_id)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except AffiliateLink.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error deleting affiliate_link: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
"""Conclusione
Abbiamo completato l'implementazione del servizio e della view per AffiliateLink. Se sei pronto a proseguire, fammi sapere e continuerò con l'implementazione delle entità successive!



conitinua
 said:
Perfetto, ora continuiamo con l'implementazione per l'entità successiva: AffiliateNotification.

1. Servizio per AffiliateNotification
services/affiliate_notification_service.py"""
import logging
from typing import List
from affiliate.models.affiliate_notification import AffiliateNotification

# Set up a logger
logger = logging.getLogger(__name__)

class AffiliateNotificationService:
    def __init__(self, request=None):
        self.request = request
        self.user = self.request.user if self.request else None

    def get_affiliate_notifications(self) -> List[AffiliateNotification]:
        try:
            affiliate_notifications = AffiliateNotification.objects.all()
            self._log_request_info()  # Logga l'informazione della richiesta
            return affiliate_notifications
        except AffiliateNotification.DoesNotExist:
            logger.warning(f"AffiliateNotification not found")
            raise ValueError("AffiliateNotification not found")

    def get_affiliate_notification_by_id(self, pk) -> AffiliateNotification:
        try:
            affiliate_notification = AffiliateNotification.objects.get(id=pk)
            self._log_request_info()  # Logga l'informazione della richiesta
            return affiliate_notification
        except AffiliateNotification.DoesNotExist:
            logger.warning(f"AffiliateNotification not found: {pk}")
            raise ValueError("AffiliateNotification not found")

    def create_affiliate_notification(self, data) -> AffiliateNotification:
        try:
            affiliate_notification = AffiliateNotification(
                message=data.get('message'),
                date_sent=data.get('date_sent'),
                is_read=data.get('is_read', False),
                notification_type=data.get('notification_type'),
                priority=data.get('priority'),
                action_required=data.get('action_required')
            )
            affiliate_notification.save()
            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"AffiliateNotification created: {affiliate_notification}")
            return affiliate_notification
        except Exception as e:
            logger.error(f"Error creating affiliate_notification: {e}")
            raise e

    def update_affiliate_notification(self, pk, data) -> AffiliateNotification:
        try:
            affiliate_notification = self.get_affiliate_notification_by_id(pk)
            for key, value in data.items():
                setattr(affiliate_notification, key, value)
            affiliate_notification.save()
            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"AffiliateNotification updated: {affiliate_notification}")
            return affiliate_notification
        except AffiliateNotification.DoesNotExist:
            logger.warning(f"AffiliateNotification not found: {pk}")
            raise ValueError("AffiliateNotification not found")
        except Exception as e:
            logger.error(f"Error updating affiliate_notification: {e}")
            raise e

    def delete_affiliate_notification(self, pk) -> None:
        try:
            affiliate_notification = self.get_affiliate_notification_by_id(pk)
            affiliate_notification.delete()
            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"AffiliateNotification deleted: {affiliate_notification}")
        except AffiliateNotification.DoesNotExist:
            logger.warning(f"AffiliateNotification not found: {pk}")
            raise ValueError("AffiliateNotification not found")
        except Exception as e:
            logger.error(f"Error deleting affiliate_notification: {e}")
            raise e

    def _log_request_info(self):
        """Logga informazioni come IP, User Agent, e cookie se necessario"""
        if self.request:
            user_ip = self.request.META.get('REMOTE_ADDR', 'Unknown')
            user_agent = self.request.META.get('HTTP_USER_AGENT', 'Unknown')
            cookies = self.request.COOKIES
            logger.info(f"Request Info - IP: {user_ip}, User-Agent: {user_agent}, Cookies: {cookies}")
"""2. View per AffiliateNotification
views/affiliate_notification_views.py"""
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from .services.affiliate_notification_service import AffiliateNotificationService
from .serializers import AffiliateNotificationSerializer
from drf_yasg.utils import swagger_auto_schema
from drf_yasg import openapi
from oauth2_provider.contrib.rest_framework import OAuth2Authentication
from rest_framework.permissions import IsAuthenticated

logger = logging.getLogger(__name__)

class AffiliateNotificationAPIView(APIView):
    permission_classes = [IsAuthenticated]
    authentication_classes = [OAuth2Authentication]

    def __init__(self, *args, **kwargs):
        self.affiliate_notification_service = AffiliateNotificationService(request=self.request)

    @swagger_auto_schema(
        operation_summary="List all affiliate notifications",
        operation_description="Returns a list of all affiliate_notification entries.",
        responses={200: openapi.Response('Successful Response', AffiliateNotificationSerializer(many=True))},
        tags=['affiliate_notification']
    )
    def get(self, request, affiliate_notification_id=None):
        try:
            if affiliate_notification_id is None:
                affiliate_notifications = self.affiliate_notification_service.get_affiliate_notifications()
                return Response(AffiliateNotificationSerializer(affiliate_notifications, many=True).data, status=status.HTTP_200_OK)
            else:
                affiliate_notification = self.affiliate_notification_service.get_affiliate_notification_by_id(affiliate_notification_id)
                return Response(AffiliateNotificationSerializer(affiliate_notification).data, status=status.HTTP_200_OK)
        except AffiliateNotification.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error fetching affiliate_notification: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Create a new affiliate notification",
        operation_description="Creates a new affiliate_notification entry.",
        request_body=AffiliateNotificationSerializer,
        responses={201: openapi.Response('Created', AffiliateNotificationSerializer)},
        tags=['affiliate_notification']
    )
    def post(self, request):
        try:
            serializer = AffiliateNotificationSerializer(data=request.data)
            if serializer.is_valid():
                affiliate_notification = self.affiliate_notification_service.create_affiliate_notification(serializer.validated_data)
                return Response(AffiliateNotificationSerializer(affiliate_notification).data, status=status.HTTP_201_CREATED)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            logger.error(f"Error creating affiliate_notification: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Update an affiliate notification entry",
        operation_description="Updates a specific affiliate_notification entry by ID.",
        request_body=AffiliateNotificationSerializer,
        responses={200: openapi.Response('Successful Response', AffiliateNotificationSerializer)},
        tags=['affiliate_notification']
    )
    def put(self, request, affiliate_notification_id=None):
        try:
            serializer = AffiliateNotificationSerializer(data=request.data)
            if serializer.is_valid():
                affiliate_notification = self.affiliate_notification_service.update_affiliate_notification(affiliate_notification_id, serializer.validated_data)
                return Response(AffiliateNotificationSerializer(affiliate_notification).data, status=status.HTTP_200_OK)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except AffiliateNotification.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error updating affiliate_notification: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Delete an affiliate notification entry",
        operation_description="Deletes a specific affiliate_notification entry by ID.",
        responses={204: 'No Content'},
        tags=['affiliate_notification']
    )
    def delete(self, request, affiliate_notification_id=None):
        try:
            self.affiliate_notification_service.delete_affiliate_notification(affiliate_notification_id)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except AffiliateNotification.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error deleting affiliate_notification: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
"""Conclusione
Abbiamo implementato il servizio e la view per AffiliateNotification. Se sei pronto, possiamo proseguire con l'implementazione delle entità successive. Fammi sapere se vuoi continuare!



continua
 said:
Perfetto, ora proseguiamo con l'implementazione per l'entità AffiliatePayout.

1. Servizio per AffiliatePayout
services/affiliate_payout_service.py"""
import logging
from typing import List
from affiliate.models.affiliate_payout import AffiliatePayout

# Set up a logger
logger = logging.getLogger(__name__)

class AffiliatePayoutService:
    def __init__(self, request=None):
        self.request = request
        self.user = self.request.user if self.request else None

    def get_affiliate_payouts(self) -> List[AffiliatePayout]:
        try:
            affiliate_payouts = AffiliatePayout.objects.all()
            self._log_request_info()  # Logga l'informazione della richiesta
            return affiliate_payouts
        except AffiliatePayout.DoesNotExist:
            logger.warning(f"AffiliatePayout not found")
            raise ValueError("AffiliatePayout not found")

    def get_affiliate_payout_by_id(self, pk) -> AffiliatePayout:
        try:
            affiliate_payout = AffiliatePayout.objects.get(id=pk)
            self._log_request_info()  # Logga l'informazione della richiesta
            return affiliate_payout
        except AffiliatePayout.DoesNotExist:
            logger.warning(f"AffiliatePayout not found: {pk}")
            raise ValueError("AffiliatePayout not found")

    def create_affiliate_payout(self, data) -> AffiliatePayout:
        try:
            affiliate_payout = AffiliatePayout(
                amount=data.get('amount'),
                currency=data.get('currency'),
                payout_date=data.get('payout_date'),
                payout_method=data.get('payout_method'),
                payout_status=data.get('payout_status'),
                transaction_id=data.get('transaction_id'),
                processing_fee=data.get('processing_fee'),
                net_amount=data.get('net_amount'),
                payout_provider=data.get('payout_provider')
            )
            affiliate_payout.save()
            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"AffiliatePayout created: {affiliate_payout}")
            return affiliate_payout
        except Exception as e:
            logger.error(f"Error creating affiliate_payout: {e}")
            raise e

    def update_affiliate_payout(self, pk, data) -> AffiliatePayout:
        try:
            affiliate_payout = self.get_affiliate_payout_by_id(pk)
            for key, value in data.items():
                setattr(affiliate_payout, key, value)
            affiliate_payout.save()
            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"AffiliatePayout updated: {affiliate_payout}")
            return affiliate_payout
        except AffiliatePayout.DoesNotExist:
            logger.warning(f"AffiliatePayout not found: {pk}")
            raise ValueError("AffiliatePayout not found")
        except Exception as e:
            logger.error(f"Error updating affiliate_payout: {e}")
            raise e

    def delete_affiliate_payout(self, pk) -> None:
        try:
            affiliate_payout = self.get_affiliate_payout_by_id(pk)
            affiliate_payout.delete()
            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"AffiliatePayout deleted: {affiliate_payout}")
        except AffiliatePayout.DoesNotExist:
            logger.warning(f"AffiliatePayout not found: {pk}")
            raise ValueError("AffiliatePayout not found")
        except Exception as e:
            logger.error(f"Error deleting affiliate_payout: {e}")
            raise e

    def _log_request_info(self):
        """Logga informazioni come IP, User Agent, e cookie se necessario"""
        if self.request:
            user_ip = self.request.META.get('REMOTE_ADDR', 'Unknown')
            user_agent = self.request.META.get('HTTP_USER_AGENT', 'Unknown')
            cookies = self.request.COOKIES
            logger.info(f"Request Info - IP: {user_ip}, User-Agent: {user_agent}, Cookies: {cookies}")
"""2. View per AffiliatePayout
views/affiliate_payout_views.py"""
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from .services.affiliate_payout_service import AffiliatePayoutService
from .serializers import AffiliatePayoutSerializer
from drf_yasg.utils import swagger_auto_schema
from drf_yasg import openapi
from oauth2_provider.contrib.rest_framework import OAuth2Authentication
from rest_framework.permissions import IsAuthenticated

logger = logging.getLogger(__name__)

class AffiliatePayoutAPIView(APIView):
    permission_classes = [IsAuthenticated]
    authentication_classes = [OAuth2Authentication]

    def __init__(self, *args, **kwargs):
        self.affiliate_payout_service = AffiliatePayoutService(request=self.request)

    @swagger_auto_schema(
        operation_summary="List all affiliate payouts",
        operation_description="Returns a list of all affiliate_payout entries.",
        responses={200: openapi.Response('Successful Response', AffiliatePayoutSerializer(many=True))},
        tags=['affiliate_payout']
    )
    def get(self, request, affiliate_payout_id=None):
        try:
            if affiliate_payout_id is None:
                affiliate_payouts = self.affiliate_payout_service.get_affiliate_payouts()
                return Response(AffiliatePayoutSerializer(affiliate_payouts, many=True).data, status=status.HTTP_200_OK)
            else:
                affiliate_payout = self.affiliate_payout_service.get_affiliate_payout_by_id(affiliate_payout_id)
                return Response(AffiliatePayoutSerializer(affiliate_payout).data, status=status.HTTP_200_OK)
        except AffiliatePayout.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error fetching affiliate_payout: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Create a new affiliate payout",
        operation_description="Creates a new affiliate_payout entry.",
        request_body=AffiliatePayoutSerializer,
        responses={201: openapi.Response('Created', AffiliatePayoutSerializer)},
        tags=['affiliate_payout']
    )
    def post(self, request):
        try:
            serializer = AffiliatePayoutSerializer(data=request.data)
            if serializer.is_valid():
                affiliate_payout = self.affiliate_payout_service.create_affiliate_payout(serializer.validated_data)
                return Response(AffiliatePayoutSerializer(affiliate_payout).data, status=status.HTTP_201_CREATED)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            logger.error(f"Error creating affiliate_payout: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Update an affiliate payout entry",
        operation_description="Updates a specific affiliate_payout entry by ID.",
        request_body=AffiliatePayoutSerializer,
        responses={200: openapi.Response('Successful Response', AffiliatePayoutSerializer)},
        tags=['affiliate_payout']
    )
    def put(self, request, affiliate_payout_id=None):
        try:
            serializer = AffiliatePayoutSerializer(data=request.data)
            if serializer.is_valid():
                affiliate_payout = self.affiliate_payout_service.update_affiliate_payout(affiliate_payout_id, serializer.validated_data)
                return Response(AffiliatePayoutSerializer(affiliate_payout).data, status=status.HTTP_200_OK)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except AffiliatePayout.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error updating affiliate_payout: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Delete an affiliate payout entry",
        operation_description="Deletes a specific affiliate_payout entry by ID.",
        responses={204: 'No Content'},
        tags=['affiliate_payout']
    )
    def delete(self, request, affiliate_payout_id=None):
        try:
            self.affiliate_payout_service.delete_affiliate_payout(affiliate_payout_id)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except AffiliatePayout.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error deleting affiliate_payout: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
"""Conclusione
Abbiamo completato l'implementazione del servizio e della view per AffiliatePayout. Ora possiamo proseguire con le altre entità quando sei pronto.

Fammi sapere se posso proseguire con la prossima entità!



continua
 said:
Perfetto! Ora proseguiamo con l'implementazione per l'entità AffiliatePerformance.

1. Servizio per AffiliatePerformance
services/affiliate_performance_service.py"""
import logging
from typing import List
from affiliate.models.affiliate_performance import AffiliatePerformance

# Set up a logger
logger = logging.getLogger(__name__)

class AffiliatePerformanceService:
    def __init__(self, request=None):
        self.request = request
        self.user = self.request.user if self.request else None

    def get_affiliate_performances(self) -> List[AffiliatePerformance]:
        try:
            affiliate_performances = AffiliatePerformance.objects.all()
            self._log_request_info()  # Logga l'informazione della richiesta
            return affiliate_performances
        except AffiliatePerformance.DoesNotExist:
            logger.warning(f"AffiliatePerformance not found")
            raise ValueError("AffiliatePerformance not found")

    def get_affiliate_performance_by_id(self, pk) -> AffiliatePerformance:
        try:
            affiliate_performance = AffiliatePerformance.objects.get(id=pk)
            self._log_request_info()  # Logga l'informazione della richiesta
            return affiliate_performance
        except AffiliatePerformance.DoesNotExist:
            logger.warning(f"AffiliatePerformance not found: {pk}")
            raise ValueError("AffiliatePerformance not found")

    def create_affiliate_performance(self, data) -> AffiliatePerformance:
        try:
            affiliate_performance = AffiliatePerformance(
                clicks=data.get('clicks'),
                conversions=data.get('conversions'),
                earnings=data.get('earnings'),
                impressions=data.get('impressions'),
                date=data.get('date'),
                affiliate=data.get('affiliate')
            )
            affiliate_performance.save()
            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"AffiliatePerformance created: {affiliate_performance}")
            return affiliate_performance
        except Exception as e:
            logger.error(f"Error creating affiliate_performance: {e}")
            raise e

    def update_affiliate_performance(self, pk, data) -> AffiliatePerformance:
        try:
            affiliate_performance = self.get_affiliate_performance_by_id(pk)
            for key, value in data.items():
                setattr(affiliate_performance, key, value)
            affiliate_performance.save()
            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"AffiliatePerformance updated: {affiliate_performance}")
            return affiliate_performance
        except AffiliatePerformance.DoesNotExist:
            logger.warning(f"AffiliatePerformance not found: {pk}")
            raise ValueError("AffiliatePerformance not found")
        except Exception as e:
            logger.error(f"Error updating affiliate_performance: {e}")
            raise e

    def delete_affiliate_performance(self, pk) -> None:
        try:
            affiliate_performance = self.get_affiliate_performance_by_id(pk)
            affiliate_performance.delete()
            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"AffiliatePerformance deleted: {affiliate_performance}")
        except AffiliatePerformance.DoesNotExist:
            logger.warning(f"AffiliatePerformance not found: {pk}")
            raise ValueError("AffiliatePerformance not found")
        except Exception as e:
            logger.error(f"Error deleting affiliate_performance: {e}")
            raise e

    def _log_request_info(self):
        """Logga informazioni come IP, User Agent, e cookie se necessario"""
        if self.request:
            user_ip = self.request.META.get('REMOTE_ADDR', 'Unknown')
            user_agent = self.request.META.get('HTTP_USER_AGENT', 'Unknown')
            cookies = self.request.COOKIES
            logger.info(f"Request Info - IP: {user_ip}, User-Agent: {user_agent}, Cookies: {cookies}")
"""2. View per AffiliatePerformance
views/affiliate_performance_views.py"""
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from .services.affiliate_performance_service import AffiliatePerformanceService
from .serializers import AffiliatePerformanceSerializer
from drf_yasg.utils import swagger_auto_schema
from drf_yasg import openapi
from oauth2_provider.contrib.rest_framework import OAuth2Authentication
from rest_framework.permissions import IsAuthenticated

logger = logging.getLogger(__name__)

class AffiliatePerformanceAPIView(APIView):
    permission_classes = [IsAuthenticated]
    authentication_classes = [OAuth2Authentication]

    def __init__(self, *args, **kwargs):
        self.affiliate_performance_service = AffiliatePerformanceService(request=self.request)

    @swagger_auto_schema(
        operation_summary="List all affiliate performances",
        operation_description="Returns a list of all affiliate_performance entries.",
        responses={200: openapi.Response('Successful Response', AffiliatePerformanceSerializer(many=True))},
        tags=['affiliate_performance']
    )
    def get(self, request, affiliate_performance_id=None):
        try:
            if affiliate_performance_id is None:
                affiliate_performances = self.affiliate_performance_service.get_affiliate_performances()
                return Response(AffiliatePerformanceSerializer(affiliate_performances, many=True).data, status=status.HTTP_200_OK)
            else:
                affiliate_performance = self.affiliate_performance_service.get_affiliate_performance_by_id(affiliate_performance_id)
                return Response(AffiliatePerformanceSerializer(affiliate_performance).data, status=status.HTTP_200_OK)
        except AffiliatePerformance.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error fetching affiliate_performance: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Create a new affiliate performance",
        operation_description="Creates a new affiliate_performance entry.",
        request_body=AffiliatePerformanceSerializer,
        responses={201: openapi.Response('Created', AffiliatePerformanceSerializer)},
        tags=['affiliate_performance']
    )
    def post(self, request):
        try:
            serializer = AffiliatePerformanceSerializer(data=request.data)
            if serializer.is_valid():
                affiliate_performance = self.affiliate_performance_service.create_affiliate_performance(serializer.validated_data)
                return Response(AffiliatePerformanceSerializer(affiliate_performance).data, status=status.HTTP_201_CREATED)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            logger.error(f"Error creating affiliate_performance: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Update an affiliate performance entry",
        operation_description="Updates a specific affiliate_performance entry by ID.",
        request_body=AffiliatePerformanceSerializer,
        responses={200: openapi.Response('Successful Response', AffiliatePerformanceSerializer)},
        tags=['affiliate_performance']
    )
    def put(self, request, affiliate_performance_id=None):
        try:
            serializer = AffiliatePerformanceSerializer(data=request.data)
            if serializer.is_valid():
                affiliate_performance = self.affiliate_performance_service.update_affiliate_performance(affiliate_performance_id, serializer.validated_data)
                return Response(AffiliatePerformanceSerializer(affiliate_performance).data, status=status.HTTP_200_OK)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except AffiliatePerformance.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error updating affiliate_performance: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Delete an affiliate performance entry",
        operation_description="Deletes a specific affiliate_performance entry by ID.",
        responses={204: 'No Content'},
        tags=['affiliate_performance']
    )
    def delete(self, request, affiliate_performance_id=None):
        try:
            self.affiliate_performance_service.delete_affiliate_performance(affiliate_performance_id)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except AffiliatePerformance.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error deleting affiliate_performance: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
"""Conclusione
Abbiamo completato l'implementazione del servizio e della view per AffiliatePerformance. Ora siamo pronti per proseguire con le altre entità.

Fammi sapere se posso proseguire con la prossima entità o se ci sono aggiustamenti che desideri fare!



continua
 said:
Perfetto! Ora proseguiamo con l'implementazione del servizio e della view per AffiliateProgramParticipation.

1. Servizio per AffiliateProgramParticipation
services/affiliate_program_participation_service.py"""
import logging
from typing import List
from affiliate.models.affiliate_program_participation import AffiliateProgramParticipation

# Set up a logger
logger = logging.getLogger(__name__)

class AffiliateProgramParticipationService:
    def __init__(self, request=None):
        self.request = request
        self.user = self.request.user if self.request else None

    def get_affiliate_program_participations(self) -> List[AffiliateProgramParticipation]:
        try:
            affiliate_program_participations = AffiliateProgramParticipation.objects.all()
            self._log_request_info()  # Logga l'informazione della richiesta
            return affiliate_program_participations
        except AffiliateProgramParticipation.DoesNotExist:
            logger.warning(f"AffiliateProgramParticipation not found")
            raise ValueError("AffiliateProgramParticipation not found")

    def get_affiliate_program_participation_by_id(self, pk) -> AffiliateProgramParticipation:
        try:
            affiliate_program_participation = AffiliateProgramParticipation.objects.get(id=pk)
            self._log_request_info()  # Logga l'informazione della richiesta
            return affiliate_program_participation
        except AffiliateProgramParticipation.DoesNotExist:
            logger.warning(f"AffiliateProgramParticipation not found: {pk}")
            raise ValueError("AffiliateProgramParticipation not found")

    def create_affiliate_program_participation(self, data) -> AffiliateProgramParticipation:
        try:
            affiliate_program_participation = AffiliateProgramParticipation(
                affiliate=data.get('affiliate'),
                program=data.get('program'),
                date_joined=data.get('date_joined'),
                reward_earned=data.get('reward_earned'),
                status=data.get('status')
            )
            affiliate_program_participation.save()
            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"AffiliateProgramParticipation created: {affiliate_program_participation}")
            return affiliate_program_participation
        except Exception as e:
            logger.error(f"Error creating affiliate_program_participation: {e}")
            raise e

    def update_affiliate_program_participation(self, pk, data) -> AffiliateProgramParticipation:
        try:
            affiliate_program_participation = self.get_affiliate_program_participation_by_id(pk)
            for key, value in data.items():
                setattr(affiliate_program_participation, key, value)
            affiliate_program_participation.save()
            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"AffiliateProgramParticipation updated: {affiliate_program_participation}")
            return affiliate_program_participation
        except AffiliateProgramParticipation.DoesNotExist:
            logger.warning(f"AffiliateProgramParticipation not found: {pk}")
            raise ValueError("AffiliateProgramParticipation not found")
        except Exception as e:
            logger.error(f"Error updating affiliate_program_participation: {e}")
            raise e

    def delete_affiliate_program_participation(self, pk) -> None:
        try:
            affiliate_program_participation = self.get_affiliate_program_participation_by_id(pk)
            affiliate_program_participation.delete()
            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"AffiliateProgramParticipation deleted: {affiliate_program_participation}")
        except AffiliateProgramParticipation.DoesNotExist:
            logger.warning(f"AffiliateProgramParticipation not found: {pk}")
            raise ValueError("AffiliateProgramParticipation not found")
        except Exception as e:
            logger.error(f"Error deleting affiliate_program_participation: {e}")
            raise e

    def _log_request_info(self):
        """Logga informazioni come IP, User Agent, e cookie se necessario"""
        if self.request:
            user_ip = self.request.META.get('REMOTE_ADDR', 'Unknown')
            user_agent = self.request.META.get('HTTP_USER_AGENT', 'Unknown')
            cookies = self.request.COOKIES
            logger.info(f"Request Info - IP: {user_ip}, User-Agent: {user_agent}, Cookies: {cookies}")
"""2. View per AffiliateProgramParticipation
views/affiliate_program_participation_views.py"""
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from .services.affiliate_program_participation_service import AffiliateProgramParticipationService
from .serializers import AffiliateProgramParticipationSerializer
from drf_yasg.utils import swagger_auto_schema
from drf_yasg import openapi
from oauth2_provider.contrib.rest_framework import OAuth2Authentication
from rest_framework.permissions import IsAuthenticated

logger = logging.getLogger(__name__)

class AffiliateProgramParticipationAPIView(APIView):
    permission_classes = [IsAuthenticated]
    authentication_classes = [OAuth2Authentication]

    def __init__(self, *args, **kwargs):
        self.affiliate_program_participation_service = AffiliateProgramParticipationService(request=self.request)

    @swagger_auto_schema(
        operation_summary="List all affiliate program participations",
        operation_description="Returns a list of all affiliate_program_participation entries.",
        responses={200: openapi.Response('Successful Response', AffiliateProgramParticipationSerializer(many=True))},
        tags=['affiliate_program_participation']
    )
    def get(self, request, affiliate_program_participation_id=None):
        try:
            if affiliate_program_participation_id is None:
                affiliate_program_participations = self.affiliate_program_participation_service.get_affiliate_program_participations()
                return Response(AffiliateProgramParticipationSerializer(affiliate_program_participations, many=True).data, status=status.HTTP_200_OK)
            else:
                affiliate_program_participation = self.affiliate_program_participation_service.get_affiliate_program_participation_by_id(affiliate_program_participation_id)
                return Response(AffiliateProgramParticipationSerializer(affiliate_program_participation).data, status=status.HTTP_200_OK)
        except AffiliateProgramParticipation.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error fetching affiliate_program_participation: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Create a new affiliate program participation",
        operation_description="Creates a new affiliate_program_participation entry.",
        request_body=AffiliateProgramParticipationSerializer,
        responses={201: openapi.Response('Created', AffiliateProgramParticipationSerializer)},
        tags=['affiliate_program_participation']
    )
    def post(self, request):
        try:
            serializer = AffiliateProgramParticipationSerializer(data=request.data)
            if serializer.is_valid():
                affiliate_program_participation = self.affiliate_program_participation_service.create_affiliate_program_participation(serializer.validated_data)
                return Response(AffiliateProgramParticipationSerializer(affiliate_program_participation).data, status=status.HTTP_201_CREATED)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            logger.error(f"Error creating affiliate_program_participation: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Update an affiliate program participation entry",
        operation_description="Updates a specific affiliate_program_participation entry by ID.",
        request_body=AffiliateProgramParticipationSerializer,
        responses={200: openapi.Response('Successful Response', AffiliateProgramParticipationSerializer)},
        tags=['affiliate_program_participation']
    )
    def put(self, request, affiliate_program_participation_id=None):
        try:
            serializer = AffiliateProgramParticipationSerializer(data=request.data)
            if serializer.is_valid():
                affiliate_program_participation = self.affiliate_program_participation_service.update_affiliate_program_participation(affiliate_program_participation_id, serializer.validated_data)
                return Response(AffiliateProgramParticipationSerializer(affiliate_program_participation).data, status=status.HTTP_200_OK)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except AffiliateProgramParticipation.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error updating affiliate_program_participation: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Delete an affiliate program participation entry",
        operation_description="Deletes a specific affiliate_program_participation entry by ID.",
        responses={204: 'No Content'},
        tags=['affiliate_program_participation']
    )
    def delete(self, request, affiliate_program_participation_id=None):
        try:
            self.affiliate_program_participation_service.delete_affiliate_program_participation(affiliate_program_participation_id)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except AffiliateProgramParticipation.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error deleting affiliate_program_participation: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
"""Conclusione
Abbiamo implementato il servizio e la view per AffiliateProgramParticipation. Ora siamo pronti per passare all'implementazione dell'entità successiva.

Fammi sapere se posso continuare o se ci sono modifiche che desideri fare!



continua
 said:
Perfetto, proseguiamo con l'implementazione del servizio e della view per AffiliateReward.

1. Servizio per AffiliateReward
services/affiliate_reward_service.py"""
import logging
from typing import List
from affiliate.models.affiliate_reward import AffiliateReward

# Set up a logger
logger = logging.getLogger(__name__)

class AffiliateRewardService:
    def __init__(self, request=None):
        self.request = request
        self.user = self.request.user if self.request else None

    def get_affiliate_rewards(self) -> List[AffiliateReward]:
        try:
            affiliate_rewards = AffiliateReward.objects.all()
            self._log_request_info()  # Logga l'informazione della richiesta
            return affiliate_rewards
        except AffiliateReward.DoesNotExist:
            logger.warning(f"AffiliateReward not found")
            raise ValueError("AffiliateReward not found")

    def get_affiliate_reward_by_id(self, pk) -> AffiliateReward:
        try:
            affiliate_reward = AffiliateReward.objects.get(id=pk)
            self._log_request_info()  # Logga l'informazione della richiesta
            return affiliate_reward
        except AffiliateReward.DoesNotExist:
            logger.warning(f"AffiliateReward not found: {pk}")
            raise ValueError("AffiliateReward not found")

    def create_affiliate_reward(self, data) -> AffiliateReward:
        try:
            affiliate_reward = AffiliateReward(
                affiliate=data.get('affiliate'),
                reward_type=data.get('reward_type'),
                reward_value=data.get('reward_value'),
                date_earned=data.get('date_earned'),
                status=data.get('status')
            )
            affiliate_reward.save()
            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"AffiliateReward created: {affiliate_reward}")
            return affiliate_reward
        except Exception as e:
            logger.error(f"Error creating affiliate_reward: {e}")
            raise e

    def update_affiliate_reward(self, pk, data) -> AffiliateReward:
        try:
            affiliate_reward = self.get_affiliate_reward_by_id(pk)
            for key, value in data.items():
                setattr(affiliate_reward, key, value)
            affiliate_reward.save()
            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"AffiliateReward updated: {affiliate_reward}")
            return affiliate_reward
        except AffiliateReward.DoesNotExist:
            logger.warning(f"AffiliateReward not found: {pk}")
            raise ValueError("AffiliateReward not found")
        except Exception as e:
            logger.error(f"Error updating affiliate_reward: {e}")
            raise e

    def delete_affiliate_reward(self, pk) -> None:
        try:
            affiliate_reward = self.get_affiliate_reward_by_id(pk)
            affiliate_reward.delete()
            self._log_request_info()  # Logga l'informazione della richiesta
            logger.info(f"AffiliateReward deleted: {affiliate_reward}")
        except AffiliateReward.DoesNotExist:
            logger.warning(f"AffiliateReward not found: {pk}")
            raise ValueError("AffiliateReward not found")
        except Exception as e:
            logger.error(f"Error deleting affiliate_reward: {e}")
            raise e

    def _log_request_info(self):
        """Logga informazioni come IP, User Agent, e cookie se necessario"""
        if self.request:
            user_ip = self.request.META.get('REMOTE_ADDR', 'Unknown')
            user_agent = self.request.META.get('HTTP_USER_AGENT', 'Unknown')
            cookies = self.request.COOKIES
            logger.info(f"Request Info - IP: {user_ip}, User-Agent: {user_agent}, Cookies: {cookies}")
"""2. View per AffiliateReward
views/affiliate_reward_views.py"""
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from .services.affiliate_reward_service import AffiliateRewardService
from .serializers import AffiliateRewardSerializer
from drf_yasg.utils import swagger_auto_schema
from drf_yasg import openapi
from oauth2_provider.contrib.rest_framework import OAuth2Authentication
from rest_framework.permissions import IsAuthenticated

logger = logging.getLogger(__name__)

class AffiliateRewardAPIView(APIView):
    permission_classes = [IsAuthenticated]
    authentication_classes = [OAuth2Authentication]

    def __init__(self, *args, **kwargs):
        self.affiliate_reward_service = AffiliateRewardService(request=self.request)

    @swagger_auto_schema(
        operation_summary="List all affiliate rewards",
        operation_description="Returns a list of all affiliate_reward entries.",
        responses={200: openapi.Response('Successful Response', AffiliateRewardSerializer(many=True))},
        tags=['affiliate_reward']
    )
    def get(self, request, affiliate_reward_id=None):
        try:
            if affiliate_reward_id is None:
                affiliate_rewards = self.affiliate_reward_service.get_affiliate_rewards()
                return Response(AffiliateRewardSerializer(affiliate_rewards, many=True).data, status=status.HTTP_200_OK)
            else:
                affiliate_reward = self.affiliate_reward_service.get_affiliate_reward_by_id(affiliate_reward_id)
                return Response(AffiliateRewardSerializer(affiliate_reward).data, status=status.HTTP_200_OK)
        except AffiliateReward.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error fetching affiliate_reward: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Create a new affiliate reward",
        operation_description="Creates a new affiliate_reward entry.",
        request_body=AffiliateRewardSerializer,
        responses={201: openapi.Response('Created', AffiliateRewardSerializer)},
        tags=['affiliate_reward']
    )
    def post(self, request):
        try:
            serializer = AffiliateRewardSerializer(data=request.data)
            if serializer.is_valid():
                affiliate_reward = self.affiliate_reward_service.create_affiliate_reward(serializer.validated_data)
                return Response(AffiliateRewardSerializer(affiliate_reward).data, status=status.HTTP_201_CREATED)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            logger.error(f"Error creating affiliate_reward: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Update an affiliate reward entry",
        operation_description="Updates a specific affiliate_reward entry by ID.",
        request_body=AffiliateRewardSerializer,
        responses={200: openapi.Response('Successful Response', AffiliateRewardSerializer)},
        tags=['affiliate_reward']
    )
    def put(self, request, affiliate_reward_id=None):
        try:
            serializer = AffiliateRewardSerializer(data=request.data)
            if serializer.is_valid():
                affiliate_reward = self.affiliate_reward_service.update_affiliate_reward(affiliate_reward_id, serializer.validated_data)
                return Response(AffiliateRewardSerializer(affiliate_reward).data, status=status.HTTP_200_OK)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except AffiliateReward.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error updating affiliate_reward: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Delete an affiliate reward entry",
        operation_description="Deletes a specific affiliate_reward entry by ID.",
        responses={204: 'No Content'},
        tags=['affiliate_reward']
    )
    def delete(self, request, affiliate_reward_id=None):
        try:
            self.affiliate_reward_service.delete_affiliate_reward(affiliate_reward_id)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except AffiliateReward.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error deleting affiliate_reward: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
"""Conclusione
Abbiamo implementato il servizio e la view per AffiliateReward. Ora possiamo proseguire con l'entità successiva.

Fammi sapere se vuoi continuare con il prossimo modello o se hai modifiche specifiche da fare!



continua
 said:
Proseguiamo ora con l'implementazione per l'entità AffiliateLink.

1. Servizio per AffiliateLink
services/affiliate_link_service.py
"""import logging
from typing import List
from affiliate.models.affiliate_link import AffiliateLink

# Set up a logger
logger = logging.getLogger(__name__)

class AffiliateLinkService:
    def __init__(self, request=None):
        self.request = request
        self.user = self.request.user if self.request else None

    def get_affiliate_links(self) -> List[AffiliateLink]:

"""
Hai fatto:
referral_bonus

affiliate_audit
affiliate_campaing
affiliate_commission
affiliate_incentive
affiliate_link
affiliate_transaction
affiliate_payout
affiliate_performance
affiliate_program_partecipation
affiliate_reward




Ricorda che nel completo le entità sono:
affiliate_audit
affiliate_campaign
affiliate_commission
affiliate_incentive
affiliate_link
affiliate_notification
affiliate_payout
affiliate_performance
affiliate_program_partecipation
affiliate_program
affiliate_reward
affiliate_settings
affiliate_support_ticket
affiliate_tier
affiliate_transaction
affiliate.py


referral_audit
referral_bonus
referral_campaign
referral_code
referral_conversion
referral_engagement
referral_level
referral_notification
referral_program_partecipation
referral_program
referral_reward
referral_settings
referral_stats
referral_transaction
referral_user
referral.py
 said:
Grazie per la precisazione. Procediamo con l'implementazione delle entità rimanenti.

1. AffiliateNotification
services/affiliate_notification_service.py"""
import logging
from typing import List
from affiliate.models.affiliate_notification import AffiliateNotification

# Set up a logger
logger = logging.getLogger(__name__)

class AffiliateNotificationService:
    def __init__(self, request=None):
        self.request = request
        self.user = self.request.user if self.request else None

    def get_affiliate_notifications(self) -> List[AffiliateNotification]:
        try:
            notifications = AffiliateNotification.objects.filter(user=self.user)
            self._log_request_info()  # Logga l'informazione della richiesta
            return notifications
        except AffiliateNotification.DoesNotExist:
            logger.warning(f"AffiliateNotification not found")
            raise ValueError("AffiliateNotification not found")

    def get_affiliate_notification_by_id(self, pk) -> AffiliateNotification:
        try:
            notification = AffiliateNotification.objects.get(id=pk, user=self.user)
            return notification
        except AffiliateNotification.DoesNotExist:
            logger.warning(f"AffiliateNotification not found: {pk}")
            raise ValueError("AffiliateNotification not found")

    def create_affiliate_notification(self, data) -> AffiliateNotification:
        try:
            notification = AffiliateNotification(
                user=self.user,
                message=data.get('message'),
                date_sent=data.get('date_sent'),
                is_read=data.get('is_read'),
                notification_type=data.get('notification_type'),
                priority=data.get('priority'),
                action_required=data.get('action_required'),
            )
            notification.save()
            logger.info(f"AffiliateNotification created: {notification}")
            return notification
        except Exception as e:
            logger.error(f"Error creating AffiliateNotification: {e}")
            raise e

    def update_affiliate_notification(self, pk, data) -> AffiliateNotification:
        try:
            notification = self.get_affiliate_notification_by_id(pk)
            for key, value in data.items():
                setattr(notification, key, value)
            notification.save()
            logger.info(f"AffiliateNotification updated: {notification}")
            return notification
        except AffiliateNotification.DoesNotExist:
            logger.warning(f"AffiliateNotification not found: {pk}")
            raise ValueError("AffiliateNotification not found")
        except Exception as e:
            logger.error(f"Error updating AffiliateNotification: {e}")
            raise e

    def delete_affiliate_notification(self, pk) -> None:
        try:
            notification = self.get_affiliate_notification_by_id(pk)
            notification.delete()
            logger.info(f"AffiliateNotification deleted: {notification}")
        except AffiliateNotification.DoesNotExist:
            logger.warning(f"AffiliateNotification not found: {pk}")
            raise ValueError("AffiliateNotification not found")
        except Exception as e:
            logger.error(f"Error deleting AffiliateNotification: {e}")
            raise e

    def _log_request_info(self):
        if self.user:
            logger.info(f"Request made by: {self.user.username} | IP: {self.request.META.get('REMOTE_ADDR')}")
"""views/affiliate_notification_views.py"""
import logging
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from drf_yasg.utils import swagger_auto_schema
from drf_yasg import openapi
from ..services.affiliate_notification_service import AffiliateNotificationService
from ..serializers import AffiliateNotificationSerializer
from dashboard.api.permissions import HasActiveSubscription

logger = logging.getLogger(__name__)

class AffiliateNotificationAPIView(APIView):
    permission_classes = [HasActiveSubscription]
    
    def __init__(self, *args, **kwargs):
        self.service = AffiliateNotificationService()

    @swagger_auto_schema(
        operation_summary="List all affiliate notifications",
        operation_description="Returns a list of all affiliate notifications for the authenticated user.",
        responses={200: openapi.Response('Successful Response', AffiliateNotificationSerializer(many=True))},
        tags=['affiliate_notification']
    )
    def get(self, request):
        try:
            notifications = self.service.get_affiliate_notifications()
            serializer = AffiliateNotificationSerializer(notifications, many=True)
            return Response(serializer.data, status=status.HTTP_200_OK)
        except Exception as e:
            logger.error(f"Error fetching notifications: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Create a new affiliate notification",
        operation_description="Creates a new affiliate notification for the authenticated user.",
        request_body=AffiliateNotificationSerializer,
        responses={201: openapi.Response('Created', AffiliateNotificationSerializer)},
        tags=['affiliate_notification']
    )
    def post(self, request):
        try:
            serializer = AffiliateNotificationSerializer(data=request.data)
            if serializer.is_valid():
                notification = self.service.create_affiliate_notification(serializer.validated_data)
                return Response(AffiliateNotificationSerializer(notification).data, status=status.HTTP_201_CREATED)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            logger.error(f"Error creating notification: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Update a specific affiliate notification",
        operation_description="Updates an existing affiliate notification by ID.",
        request_body=AffiliateNotificationSerializer,
        responses={200: openapi.Response('Successful Response', AffiliateNotificationSerializer)},
        tags=['affiliate_notification']
    )
    def put(self, request, notification_id=None):
        try:
            serializer = AffiliateNotificationSerializer(data=request.data)
            if serializer.is_valid():
                notification = self.service.update_affiliate_notification(notification_id, serializer.validated_data)
                return Response(AffiliateNotificationSerializer(notification).data, status=status.HTTP_200_OK)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            logger.error(f"Error updating notification: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Delete a specific affiliate notification",
        operation_description="Deletes a specific affiliate notification by ID.",
        responses={204: 'No Content', 404: 'Not Found', 500: 'Internal Server Error'},
        tags=['affiliate_notification']
    )
    def delete(self, request, notification_id=None):
        try:
            self.service.delete_affiliate_notification(notification_id)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except Exception as e:
            logger.error(f"Error deleting notification: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
"""2. AffiliatePayout
services/affiliate_payout_service.py"""
import logging
from typing import List
from affiliate.models.affiliate_payout import AffiliatePayout

# Set up a logger
logger = logging.getLogger(__name__)

class AffiliatePayoutService:
    def __init__(self, request=None):
        self.request = request
        self.user = self.request.user if self.request else None

    def get_affiliate_payouts(self) -> List[AffiliatePayout]:
        try:
            payouts = AffiliatePayout.objects.filter(user=self.user)
            self._log_request_info()  # Logga l'informazione della richiesta
            return payouts
        except AffiliatePayout.DoesNotExist:
            logger.warning(f"AffiliatePayout not found")
            raise ValueError("AffiliatePayout not found")

    def get_affiliate_payout_by_id(self, pk) -> AffiliatePayout:
        try:
            payout = AffiliatePayout.objects.get(id=pk, user=self.user)
            return payout
        except AffiliatePayout.DoesNotExist:
            logger.warning(f"AffiliatePayout not found: {pk}")
            raise ValueError("AffiliatePayout not found")

    def create_affiliate_payout(self, data) -> AffiliatePayout:
        try:
            payout = AffiliatePayout(
                user=self.user,
                amount=data.get('amount'),
                currency=data.get('currency'),
                payout_date=data.get('payout_date'),
                payout_method=data.get('payout_method'),
                payout_status=data.get('payout_status'),
                transaction_id=data.get('transaction_id'),
                processing_fee=data.get('processing_fee'),
                net_amount=data.get('net_amount'),
                payout_provider=data.get('payout_provider'),
            )
            payout.save()
            logger.info(f"AffiliatePayout created: {payout}")
            return payout
        except Exception as e:
            logger.error(f"Error creating AffiliatePayout: {e}")
            raise e

    def update_affiliate_payout(self, pk, data) -> AffiliatePayout:
        try:
            payout = self.get_affiliate_payout_by_id(pk)
            for key, value in data.items():
                setattr(payout, key, value)
            payout.save()
            logger.info(f"AffiliatePayout updated: {payout}")
            return payout
        except AffiliatePayout.DoesNotExist:
            logger.warning(f"AffiliatePayout not found: {pk}")
            raise ValueError("AffiliatePayout not found")
        except Exception as e:
            logger.error(f"Error updating AffiliatePayout: {e}")
            raise e

    def delete_affiliate_payout(self, pk) -> None:
        try:
            payout = self.get_affiliate_payout_by_id(pk)
            payout.delete()
            logger.info(f"AffiliatePayout deleted: {payout}")
        except AffiliatePayout.DoesNotExist:
            logger.warning(f"AffiliatePayout not found: {pk}")
            raise ValueError("AffiliatePayout not found")
        except Exception as e:
            logger.error(f"Error deleting AffiliatePayout: {e}")
            raise e

    def _log_request_info(self):
        if self.user:
            logger.info(f"Request made by: {self.user.username} | IP: {self.request.META.get('REMOTE_ADDR')}")
"""views/affiliate_payout_views.py"""
import logging
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from drf_yasg.utils import swagger_auto_schema
from drf_yasg import openapi
from ..services.affiliate_payout_service import AffiliatePayoutService
from ..serializers import AffiliatePayoutSerializer
from dashboard.api.permissions import HasActiveSubscription

logger = logging.getLogger(__name__)

class AffiliatePayoutAPIView(APIView):
    permission_classes = [HasActiveSubscription]

    def __init__(self, *args, **kwargs):
        self.service = AffiliatePayoutService()

    @swagger_auto_schema(
        operation_summary="List all affiliate payouts",
        operation_description="Returns a list of all affiliate payouts for the authenticated user.",
        responses={200: openapi.Response('Successful Response', AffiliatePayoutSerializer(many=True))},
        tags=['affiliate_payout']
    )
    def get(self, request):
        try:
            payouts = self.service.get_affiliate_payouts()
            serializer = AffiliatePayoutSerializer(payouts, many=True)
            return Response(serializer.data, status=status.HTTP_200_OK)
        except Exception as e:
            logger.error(f"Error fetching payouts: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Create a new affiliate payout",
        operation_description="Creates a new affiliate payout for the authenticated user.",
        request_body=AffiliatePayoutSerializer,
        responses={201: openapi.Response('Created', AffiliatePayoutSerializer)},
        tags=['affiliate_payout']
    )
    def post(self, request):
        try:
            serializer = AffiliatePayoutSerializer(data=request.data)
            if serializer.is_valid():
                payout = self.service.create_affiliate_payout(serializer.validated_data)
                return Response(AffiliatePayoutSerializer(payout).data, status=status.HTTP_201_CREATED)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            logger.error(f"Error creating payout: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Update a specific affiliate payout",
        operation_description="Updates an existing affiliate payout by ID.",
        request_body=AffiliatePayoutSerializer,
        responses={200: openapi.Response('Successful Response', AffiliatePayoutSerializer)},
        tags=['affiliate_payout']
    )
    def put(self, request, payout_id=None):
        try:
            serializer = AffiliatePayoutSerializer(data=request.data)
            if serializer.is_valid():
                payout = self.service.update_affiliate_payout(payout_id, serializer.validated_data)
                return Response(AffiliatePayoutSerializer(payout).data, status=status.HTTP_200_OK)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            logger.error(f"Error updating payout: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Delete a specific affiliate payout",
        operation_description="Deletes a specific affiliate payout by ID.",
        responses={204: 'No Content', 404: 'Not Found', 500: 'Internal Server Error'},
        tags=['affiliate_payout']
    )
    def delete(self, request, payout_id=None):
        try:
            self.service.delete_affiliate_payout(payout_id)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except Exception as e:
            logger.error(f"Error deleting payout: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
"""Abbiamo implementato AffiliateNotification e AffiliatePayout. Se vuoi, posso continuare con altre entità o apportare modifiche a quelle già fatte.




Hai fatto:
referral_bonus

affiliate_audit
affiliate_campaing
affiliate_commission
affiliate_incentive
affiliate_link
affiliate_transaction
affiliate_payout
affiliate_performance
affiliate_program_partecipation
affiliate_reward
affiliate_notification




Ricorda che nel completo le entità sono:
affiliate_audit
affiliate_campaign
affiliate_commission
affiliate_incentive
affiliate_link
affiliate_notification
affiliate_payout
affiliate_performance
affiliate_program_partecipation
affiliate_program
affiliate_reward
affiliate_settings
affiliate_support_ticket
affiliate_tier
affiliate_transaction
affiliate.py


referral_audit
referral_bonus
referral_campaign
referral_code
referral_conversion
referral_engagement
referral_level
referral_notification
referral_program_partecipation
referral_program
referral_reward
referral_settings
referral_stats
referral_transaction
referral_user
referral.py
 said:
Perfetto, grazie per il promemoria! Continuerò con le implementazioni delle entità rimanenti. Procediamo con affiliate_settings, affiliate_support_ticket, affiliate_tier, e affiliate_program.

3. AffiliateSettings
services/affiliate_settings_service.py"""
import logging
from affiliate.models.affiliate_settings import AffiliateSettings

# Set up a logger
logger = logging.getLogger(__name__)

class AffiliateSettingsService:
    def __init__(self, request=None):
        self.request = request
        self.user = self.request.user if self.request else None

    def get_affiliate_settings(self) -> AffiliateSettings:
        try:
            settings = AffiliateSettings.objects.get(user=self.user)
            return settings
        except AffiliateSettings.DoesNotExist:
            logger.warning(f"AffiliateSettings not found for user: {self.user}")
            raise ValueError("AffiliateSettings not found")

    def update_affiliate_settings(self, data) -> AffiliateSettings:
        try:
            settings = self.get_affiliate_settings()
            for key, value in data.items():
                setattr(settings, key, value)
            settings.save()
            logger.info(f"AffiliateSettings updated: {settings}")
            return settings
        except AffiliateSettings.DoesNotExist:
            logger.warning(f"AffiliateSettings not found for user: {self.user}")
            raise ValueError("AffiliateSettings not found")
        except Exception as e:
            logger.error(f"Error updating AffiliateSettings: {e}")
            raise e
"""views/affiliate_settings_views.py"""
import logging
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from drf_yasg.utils import swagger_auto_schema
from drf_yasg import openapi
from ..services.affiliate_settings_service import AffiliateSettingsService
from ..serializers import AffiliateSettingsSerializer
from dashboard.api.permissions import HasActiveSubscription

logger = logging.getLogger(__name__)

class AffiliateSettingsAPIView(APIView):
    permission_classes = [HasActiveSubscription]
    
    def __init__(self, *args, **kwargs):
        self.service = AffiliateSettingsService()

    @swagger_auto_schema(
        operation_summary="Get affiliate settings",
        operation_description="Retrieve affiliate settings for the authenticated user.",
        responses={200: openapi.Response('Successful Response', AffiliateSettingsSerializer)},
        tags=['affiliate_settings']
    )
    def get(self, request):
        try:
            settings = self.service.get_affiliate_settings()
            serializer = AffiliateSettingsSerializer(settings)
            return Response(serializer.data, status=status.HTTP_200_OK)
        except Exception as e:
            logger.error(f"Error fetching settings: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Update affiliate settings",
        operation_description="Updates the affiliate settings for the authenticated user.",
        request_body=AffiliateSettingsSerializer,
        responses={200: openapi.Response('Successful Response', AffiliateSettingsSerializer)},
        tags=['affiliate_settings']
    )
    def put(self, request):
        try:
            serializer = AffiliateSettingsSerializer(data=request.data)
            if serializer.is_valid():
                settings = self.service.update_affiliate_settings(serializer.validated_data)
                return Response(AffiliateSettingsSerializer(settings).data, status=status.HTTP_200_OK)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            logger.error(f"Error updating settings: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
"""4. AffiliateSupportTicket
services/affiliate_support_ticket_service.py"""
import logging
from affiliate.models.affiliate_support_ticket import AffiliateSupportTicket

# Set up a logger
logger = logging.getLogger(__name__)

class AffiliateSupportTicketService:
    def __init__(self, request=None):
        self.request = request
        self.user = self.request.user if self.request else None

    def get_support_tickets(self) -> List[AffiliateSupportTicket]:
        try:
            tickets = AffiliateSupportTicket.objects.filter(user=self.user)
            return tickets
        except AffiliateSupportTicket.DoesNotExist:
            logger.warning(f"AffiliateSupportTicket not found")
            raise ValueError("AffiliateSupportTicket not found")

    def get_support_ticket_by_id(self, pk) -> AffiliateSupportTicket:
        try:
            ticket = AffiliateSupportTicket.objects.get(id=pk, user=self.user)
            return ticket
        except AffiliateSupportTicket.DoesNotExist:
            logger.warning(f"AffiliateSupportTicket not found: {pk}")
            raise ValueError("AffiliateSupportTicket not found")

    def create_support_ticket(self, data) -> AffiliateSupportTicket:
        try:
            ticket = AffiliateSupportTicket(
                user=self.user,
                subject=data.get('subject'),
                message=data.get('message'),
                status=data.get('status'),
                priority=data.get('priority'),
                date_created=data.get('date_created'),
            )
            ticket.save()
            logger.info(f"AffiliateSupportTicket created: {ticket}")
            return ticket
        except Exception as e:
            logger.error(f"Error creating AffiliateSupportTicket: {e}")
            raise e

    def update_support_ticket(self, pk, data) -> AffiliateSupportTicket:
        try:
            ticket = self.get_support_ticket_by_id(pk)
            for key, value in data.items():
                setattr(ticket, key, value)
            ticket.save()
            logger.info(f"AffiliateSupportTicket updated: {ticket}")
            return ticket
        except AffiliateSupportTicket.DoesNotExist:
            logger.warning(f"AffiliateSupportTicket not found: {pk}")
            raise ValueError("AffiliateSupportTicket not found")
        except Exception as e:
            logger.error(f"Error updating AffiliateSupportTicket: {e}")
            raise e

    def delete_support_ticket(self, pk) -> None:
        try:
            ticket = self.get_support_ticket_by_id(pk)
            ticket.delete()
            logger.info(f"AffiliateSupportTicket deleted: {ticket}")
        except AffiliateSupportTicket.DoesNotExist:
            logger.warning(f"AffiliateSupportTicket not found: {pk}")
            raise ValueError("AffiliateSupportTicket not found")
        except Exception as e:
            logger.error(f"Error deleting AffiliateSupportTicket: {e}")
            raise e
"""views/affiliate_support_ticket_views.py"""
import logging
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from drf_yasg.utils import swagger_auto_schema
from drf_yasg import openapi
from ..services.affiliate_support_ticket_service import AffiliateSupportTicketService
from ..serializers import AffiliateSupportTicketSerializer
from dashboard.api.permissions import HasActiveSubscription

logger = logging.getLogger(__name__)

class AffiliateSupportTicketAPIView(APIView):
    permission_classes = [HasActiveSubscription]
    
    def __init__(self, *args, **kwargs):
        self.service = AffiliateSupportTicketService()

    @swagger_auto_schema(
        operation_summary="List support tickets",
        operation_description="Returns a list of all support tickets for the authenticated user.",
        responses={200: openapi.Response('Successful Response', AffiliateSupportTicketSerializer(many=True))},
        tags=['affiliate_support_ticket']
    )
    def get(self, request):
        try:
            tickets = self.service.get_support_tickets()
            serializer = AffiliateSupportTicketSerializer(tickets, many=True)
            return Response(serializer.data, status=status.HTTP_200_OK)
        except Exception as e:
            logger.error(f"Error fetching support tickets: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Create a new support ticket",
        operation_description="Creates a new support ticket for the authenticated user.",
        request_body=AffiliateSupportTicketSerializer,
        responses={201: openapi.Response('Created', AffiliateSupportTicketSerializer)},
        tags=['affiliate_support_ticket']
    )
    def post(self, request):
        try:
            serializer = AffiliateSupportTicketSerializer(data=request.data)
            if serializer.is_valid():
                ticket = self.service.create_support_ticket(serializer.validated_data)
                return Response(AffiliateSupportTicketSerializer(ticket).data, status=status.HTTP_201_CREATED)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            logger.error(f"Error creating support ticket: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Update an existing support ticket",
        operation_description="Updates an existing support ticket by ID.",
        request_body=AffiliateSupportTicketSerializer,
        responses={200: openapi.Response('Successful Response', AffiliateSupportTicketSerializer)},
        tags=['affiliate_support_ticket']
    )
    def put(self, request, ticket_id=None):
        try:
            serializer = AffiliateSupportTicketSerializer(data=request.data)
            if serializer.is_valid():
                ticket = self.service.update_support_ticket(ticket_id, serializer.validated_data)
                return Response(AffiliateSupportTicketSerializer(ticket).data, status=status.HTTP_200_OK)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            logger.error(f"Error updating support ticket: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Delete a support ticket",
        operation_description="Deletes a support ticket by ID.",
        responses={204: 'No Content', 404: 'Not Found', 500: 'Internal Server Error'},
        tags=['affiliate_support_ticket']
    )
    def delete(self, request, ticket_id=None):
        try:
            self.service.delete_support_ticket(ticket_id)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except Exception as e:
            logger.error(f"Error deleting support ticket: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
"""5. AffiliateTier
services/affiliate_tier_service.py"""
import logging
from affiliate.models.affiliate_tier import AffiliateTier

# Set up a logger
logger = logging.getLogger(__name__)

class AffiliateTierService:
    def __init__(self, request=None):
        self.request = request
        self.user = self.request.user if self.request else None

    def get_affiliate_tiers(self) -> List[AffiliateTier]:
        try:
            tiers = AffiliateTier.objects.all()
            return tiers
        except AffiliateTier.DoesNotExist:
            logger.warning(f"AffiliateTier not found")
            raise ValueError("AffiliateTier not found")

    def create_affiliate_tier(self, data) -> AffiliateTier:
        try:
            tier = AffiliateTier(
                name=data.get('name'),
                description=data.get('description'),
                reward_percentage=data.get('reward_percentage'),
                minimum_sales=data.get('minimum_sales'),
            )
            tier.save()
            logger.info(f"AffiliateTier created: {tier}")
            return tier
        except Exception as e:
            logger.error(f"Error creating AffiliateTier: {e}")
            raise e

    def update_affiliate_tier(self, pk, data) -> AffiliateTier:
        try:
            tier = AffiliateTier.objects.get(id=pk)
            for key, value in data.items():
                setattr(tier, key, value)
            tier.save()
            logger.info(f"AffiliateTier updated: {tier}")
            return tier
        except AffiliateTier.DoesNotExist:
            logger.warning(f"AffiliateTier not found: {pk}")
            raise ValueError("AffiliateTier not found")
        except Exception as e:
            logger.error(f"Error updating AffiliateTier: {e}")
            raise e

    def delete_affiliate_tier(self, pk) -> None:
        try:
            tier = AffiliateTier.objects.get(id=pk)
            tier.delete()
            logger.info(f"AffiliateTier deleted: {tier}")
        except AffiliateTier.DoesNotExist:
            logger.warning(f"AffiliateTier not found: {pk}")
            raise ValueError("AffiliateTier not found")
        except Exception as e:
            logger.error(f"Error deleting AffiliateTier: {e}")
            raise e
"""views/affiliate_tier_views.py"""
import logging
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from drf_yasg.utils import swagger_auto_schema
from drf_yasg import openapi
from ..services.affiliate_tier_service import AffiliateTierService
from ..serializers import AffiliateTierSerializer
from dashboard.api.permissions import HasActiveSubscription

logger = logging.getLogger(__name__)

class AffiliateTierAPIView(APIView):
    permission_classes = [HasActiveSubscription]
    
    def __init__(self, *args, **kwargs):
        self.service = AffiliateTierService()

    @swagger_auto_schema(
        operation_summary="List affiliate tiers",
        operation_description="Returns a list of all affiliate tiers.",
        responses={200: openapi.Response('Successful Response', AffiliateTierSerializer(many=True))},
        tags=['affiliate_tier']
    )
    def get(self, request):
        try:
            tiers = self.service.get_affiliate_tiers()
            serializer = AffiliateTierSerializer(tiers, many=True)
            return Response(serializer.data, status=status.HTTP_200_OK)
        except Exception as e:
            logger.error(f"Error fetching tiers: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Create a new affiliate tier",
        operation_description="Creates a new affiliate tier.",
        request_body=AffiliateTierSerializer,
        responses={201: openapi.Response('Created', AffiliateTierSerializer)},
        tags=['affiliate_tier']
    )
    def post(self, request):
        try:
            serializer = AffiliateTierSerializer(data=request.data)
            if serializer.is_valid():
                tier = self.service.create_affiliate_tier(serializer.validated_data)
                return Response(AffiliateTierSerializer(tier).data, status=status.HTTP_201_CREATED)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            logger.error(f"Error creating tier: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Update a specific affiliate tier",
        operation_description="Updates an existing affiliate tier by ID.",
        request_body=AffiliateTierSerializer,
        responses={200: openapi.Response('Successful Response', AffiliateTierSerializer)},
        tags=['affiliate_tier']
    )
    def put(self, request, tier_id=None):
        try:
            serializer = AffiliateTierSerializer(data=request.data)
            if serializer.is_valid():
                tier = self.service.update_affiliate_tier(tier_id, serializer.validated_data)
                return Response(AffiliateTierSerializer(tier).data, status=status.HTTP_200_OK)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            logger.error(f"Error updating tier: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Delete a specific affiliate tier",
        operation_description="Deletes a specific affiliate tier by ID.",
        responses={204: 'No Content', 404: 'Not Found', 500: 'Internal Server Error'},
        tags=['affiliate_tier']
    )
    def delete(self, request, tier_id=None):
        try:
            self.service.delete_affiliate_tier(tier_id)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except Exception as e:
            logger.error(f"Error deleting tier: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
"""6. Affiliate Program
services/affiliate_program_service.py"""
import logging
from affiliate.models.affiliate_program import AffiliateProgram

# Set up a logger
logger = logging.getLogger(__name__)

class AffiliateProgramService:
    def __init__(self, request=None):
        self.request = request
        self.user = self.request.user if self.request else None

    def get_affiliate_programs(self) -> List[AffiliateProgram]:
        try:
            programs = AffiliateProgram.objects.all()
            return programs
        except AffiliateProgram.DoesNotExist:
            logger.warning(f"AffiliateProgram not found")
            raise ValueError("AffiliateProgram not found")

    def create_affiliate_program(self, data) -> AffiliateProgram:
        try:
            program = AffiliateProgram(
                name=data.get('name'),
                description=data.get('description'),
                start_date=data.get('start_date'),
                end_date=data.get('end_date'),
                status=data.get('status'),
            )
            program.save()
            logger.info(f"AffiliateProgram created: {program}")
            return program
        except Exception as e:
            logger.error(f"Error creating AffiliateProgram: {e}")
            raise e

    def update_affiliate_program(self, pk, data) -> AffiliateProgram:
        try:
            program = AffiliateProgram.objects.get(id=pk)
            for key, value in data.items():
                setattr(program, key, value)
            program.save()
            logger.info(f"AffiliateProgram updated: {program}")
            return program
        except AffiliateProgram.DoesNotExist:
            logger.warning(f"AffiliateProgram not found: {pk}")
            raise ValueError("AffiliateProgram not found")
        except Exception as e:
            logger.error(f"Error updating AffiliateProgram: {e}")
            raise e

    def delete_affiliate_program(self, pk) -> None:
        try:
            program = AffiliateProgram.objects.get(id=pk)
            program.delete()
            logger.info(f"AffiliateProgram deleted: {program}")
        except AffiliateProgram.DoesNotExist:
            logger.warning(f"AffiliateProgram not found: {pk}")
            raise ValueError("AffiliateProgram not found")
        except Exception as e:
            logger.error(f"Error deleting AffiliateProgram: {e}")
            raise e
"""views/affiliate_program_views.py"""
import logging
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from drf_yasg.utils import swagger_auto_schema
from drf_yasg import openapi
from ..services.affiliate_program_service import AffiliateProgramService
from ..serializers import AffiliateProgramSerializer
from dashboard.api.permissions import HasActiveSubscription

logger = logging.getLogger(__name__)

class AffiliateProgramAPIView(APIView):
    permission_classes = [HasActiveSubscription]
    
    def __init__(self, *args, **kwargs):
        self.service = AffiliateProgramService()

    @swagger_auto_schema(
        operation_summary="List affiliate programs",
        operation_description="Returns a list of all affiliate programs.",
        responses={200: openapi.Response('Successful Response', AffiliateProgramSerializer(many=True))},
        tags=['affiliate_program']
    )
    def get(self, request):
        try:
            programs = self.service.get_affiliate_programs()
            serializer = AffiliateProgramSerializer(programs, many=True)
            return Response(serializer.data, status=status.HTTP_200_OK)
        except Exception as e:
            logger.error(f"Error fetching programs: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Create a new affiliate program",
        operation_description="Creates a new affiliate program.",
        request_body=AffiliateProgramSerializer,
        responses={201: openapi.Response('Created', AffiliateProgramSerializer)},
        tags=['affiliate_program']
    )
    def post(self, request):
        try:
            serializer = AffiliateProgramSerializer(data=request.data)
            if serializer.is_valid():
                program = self.service.create_affiliate_program(serializer.validated_data)
                return Response(AffiliateProgramSerializer(program).data, status=status.HTTP_201_CREATED)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            logger.error(f"Error creating program: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Update a specific affiliate program",
        operation_description="Updates an existing affiliate program by ID.",
        request_body=AffiliateProgramSerializer,
        responses={200: openapi.Response('Successful Response', AffiliateProgramSerializer)},
        tags=['affiliate_program']
    )
    def put(self, request, program_id=None):
        try:
            serializer = AffiliateProgramSerializer(data=request.data)
            if serializer.is_valid():
                program = self.service.update_affiliate_program(program_id, serializer.validated_data)
                return Response(AffiliateProgramSerializer(program).data, status=status.HTTP_200_OK)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            logger.error(f"Error updating program: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Delete a specific affiliate program",
        operation_description="Deletes a specific affiliate program by ID.",
        responses={204: 'No Content', 404: 'Not Found', 500: 'Internal Server Error'},
        tags=['affiliate_program']
    )
    def delete(self, request, program_id=None):
        try:
            self.service.delete_affiliate_program(program_id)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except Exception as e:
            logger.error(f"Error deleting program: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
"""Questo conclude il lavoro sugli endpoint per AffiliateSettings, AffiliateSupportTicket, AffiliateTier, e AffiliateProgram.

Se hai altre richieste o se hai bisogno di ulteriori chiarimenti, fammi sapere!




Hai fatto:
referral_bonus

affiliate_audit
affiliate_campaing
affiliate_commission
affiliate_incentive
affiliate_link
affiliate_transaction
affiliate_payout
affiliate_performance
affiliate_program_partecipation
affiliate_reward
affiliate_notification
affiliate_settings
affiliate_support_ticket
affiliate_tier
affiliate_program



Ricorda che nel completo le entità sono:
affiliate_audit
affiliate_campaign
affiliate_commission
affiliate_incentive
affiliate_link
affiliate_notification
affiliate_payout
affiliate_performance
affiliate_program_partecipation
affiliate_program
affiliate_reward
affiliate_settings
affiliate_support_ticket
affiliate_tier
affiliate_transaction
affiliate.py


referral_audit
referral_bonus
referral_campaign
referral_code
referral_conversion
referral_engagement
referral_level
referral_notification
referral_program_partecipation
referral_program
referral_reward
referral_settings
referral_stats
referral_transaction
referral_user
referral.py
 said:
​



referral_audit
referral_bonus
referral_campaign
referral_code
referral_conversion
referral_engagement
referral_level
referral_notification
referral_program_partecipation
referral_program
referral_reward
referral_settings
referral_stats
referral_transaction
referral_user
referral
DEVI FARE ANCHE QUESTI
 said:
Capisco! Procederò ora con la realizzazione delle classi di servizio e delle views per le entità mancanti nel modulo referral. Comincerò con la prima entità e procederò step-by-step, proprio come abbiamo fatto prima.

Partiamo con la prima entità: referral_audit.

ReferralAuditService e ReferralAuditAPIView
ReferralAuditService:"""

import logging
from typing import List
from referral.models.referral_audit import ReferralAudit

# Set up a logger
logger = logging.getLogger(__name__)

class ReferralAuditService():
    def __init__(self) -> None:
        pass
    
    def get_referral_audits(self) -> List[ReferralAudit]:
        try:
            referral_audits = ReferralAudit.objects.all()
            return referral_audits
        except ReferralAudit.DoesNotExist:
            logger.warning("ReferralAudit not found")
            raise ValueError("ReferralAudit not found")
     
    def get_referral_audit(self, pk) -> ReferralAudit:
        try:
            referral_audit = ReferralAudit.objects.get(id=pk)
            return referral_audit
        except ReferralAudit.DoesNotExist:
            logger.warning(f"ReferralAudit not found: {pk}")
            raise ValueError("ReferralAudit not found")
    
    def create_referral_audit(self, data) -> ReferralAudit:
        try:
            referral_audit = ReferralAudit(
                action_taken = data.get('action_taken'),
                action_date = data.get('action_date'),
                ip_address = data.get('ip_address'),
                device_info = data.get('device_info'),
                location = data.get('location')
            )
            referral_audit.save()
            logger.info(f"ReferralAudit created: {referral_audit}")
            return referral_audit
        except Exception as e:
            logger.error(f"Error creating referral_audit: {e}")
            raise e
    
    def update_referral_audit(self, pk, data) -> ReferralAudit:
        try:
            referral_audit = self.get_referral_audit(pk)
            for key, value in data.items():
                setattr(referral_audit, key, value)
            referral_audit.save()
            logger.info(f"ReferralAudit updated: {referral_audit}")
            return referral_audit
        except ReferralAudit.DoesNotExist:
            logger.warning(f"ReferralAudit not found: {pk}")
            raise ValueError("ReferralAudit not found")
        except Exception as e:
            logger.error(f"Error updating referral_audit: {e}")
            raise e
    
    def delete_referral_audit(self, pk) -> None:
        try:
            referral_audit = self.get_referral_audit(pk)
            referral_audit.delete()
            logger.info(f"ReferralAudit deleted: {referral_audit}")
        except ReferralAudit.DoesNotExist:
            logger.warning(f"ReferralAudit not found: {pk}")
            raise ValueError("ReferralAudit not found")
        except Exception as e:
            logger.error(f"Error deleting referral_audit: {e}")
            raise e
"""ReferralAuditAPIView:
"""
import logging
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from referral.models.referral_audit import ReferralAudit
from referral.serializers import ReferralAuditSerializer
from referral.services.referral_audit_service import ReferralAuditService
from rest_framework.permissions import IsAuthenticated
from oauth2_provider.contrib.rest_framework import OAuth2Authentication
from drf_yasg.utils import swagger_auto_schema
from drf_yasg import openapi

# Set up a logger
logger = logging.getLogger(__name__)

class ReferralAuditAPIView(APIView):
    permission_classes = [IsAuthenticated]
    authentication_classes = [OAuth2Authentication]

    def __init__(self, *args, **kwargs):
        self.referral_audit_service = ReferralAuditService()

    @swagger_auto_schema(
        operation_summary="List all referral audits",
        operation_description="Returns a list of all referral audit entries.",
        responses={
            200: openapi.Response('Successful Response', ReferralAuditSerializer(many=True)),
            500: 'Internal Server Error'
        },
        tags=['referral_audit']
    )
    def get(self, request, )

"""
DEVI FARE ANCHE LE MODIFICHE CHE MI AVEVI MOSTRATO PER LE CLASSI PER AFFILIATE PER GESTIRE I COOKIE E LE ALTRE INFORMAZIONI DI REQUEST
 said:
Perfetto, per gestire correttamente i cookie e altre informazioni provenienti dalla richiesta (come l'IP, il dispositivo, la posizione, ecc.), dovrò adattare sia i servizi che le views. Procederò con l'integrazione delle informazioni di request in modo che tutte le azioni possano essere monitorate correttamente, come già accennato nei servizi per affiliate.

Iniziamo con la classe ReferralAuditService e ReferralAuditAPIView adattandola per gestire queste informazioni.

ReferralAuditService con gestione dei dati di request
ReferralAuditService (modificato per request, cookies, etc.):
"""
import logging
from typing import List
from referral.models.referral_audit import ReferralAudit
from django.utils.timezone import now

# Set up a logger
logger = logging.getLogger(__name__)

class ReferralAuditService():
    def __init__(self) -> None:
        pass
    
    def get_referral_audits(self) -> List[ReferralAudit]:
        try:
            referral_audits = ReferralAudit.objects.all()
            return referral_audits
        except ReferralAudit.DoesNotExist:
            logger.warning("ReferralAudit not found")
            raise ValueError("ReferralAudit not found")
     
    def get_referral_audit(self, pk) -> ReferralAudit:
        try:
            referral_audit = ReferralAudit.objects.get(id=pk)
            return referral_audit
        except ReferralAudit.DoesNotExist:
            logger.warning(f"ReferralAudit not found: {pk}")
            raise ValueError("ReferralAudit not found")
    
    def create_referral_audit(self, data, request) -> ReferralAudit:
        """
        Crea un audit di referral. Registra l'azione e altre informazioni come IP, dispositivo, location.
        """
        try:
            # Recupero delle informazioni dalla richiesta
            ip_address = request.META.get('REMOTE_ADDR')
            device_info = request.META.get('HTTP_USER_AGENT')
            location = self.get_location_from_request(request)

            referral_audit = ReferralAudit(
                action_taken = data.get('action_taken'),
                action_date = now(),  # Impostiamo la data dell'azione come l'ora attuale
                ip_address = ip_address,
                device_info = device_info,
                location = location
            )
            referral_audit.save()
            logger.info(f"ReferralAudit created: {referral_audit}")
            return referral_audit
        except Exception as e:
            logger.error(f"Error creating referral_audit: {e}")
            raise e

    def update_referral_audit(self, pk, data, request) -> ReferralAudit:
        """
        Modifica un audit esistente.
        """
        try:
            referral_audit = self.get_referral_audit(pk)
            for key, value in data.items():
                setattr(referral_audit, key, value)
            referral_audit.save()
            logger.info(f"ReferralAudit updated: {referral_audit}")
            return referral_audit
        except ReferralAudit.DoesNotExist:
            logger.warning(f"ReferralAudit not found: {pk}")
            raise ValueError("ReferralAudit not found")
        except Exception as e:
            logger.error(f"Error updating referral_audit: {e}")
            raise e
    
    def delete_referral_audit(self, pk) -> None:
        try:
            referral_audit = self.get_referral_audit(pk)
            referral_audit.delete()
            logger.info(f"ReferralAudit deleted: {referral_audit}")
        except ReferralAudit.DoesNotExist:
            logger.warning(f"ReferralAudit not found: {pk}")
            raise ValueError("ReferralAudit not found")
        except Exception as e:
            logger.error(f"Error deleting referral_audit: {e}")
            raise e
    
    def get_location_from_request(self, request):
        """
        Questo è un esempio di come si può ottenere la posizione da una richiesta.
        In pratica dovresti implementare una logica basata su un servizio esterno di geolocalizzazione.
        """
        # Questo è un esempio di base, basato sull'IP, puoi migliorarlo.
        ip_address = request.META.get('REMOTE_ADDR')
        # Pseudo-servizio di geolocalizzazione (da integrare con un servizio reale)
        location = f"Geo info for {ip_address}"  # Placeholder per esempio
        return location
"""Ora, modifichiamo anche la ReferralAuditAPIView per includere la gestione dei cookie e delle informazioni di request:
ReferralAuditAPIView con gestione dei dati di request
"""
import logging
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from referral.models.referral_audit import ReferralAudit
from referral.serializers import ReferralAuditSerializer
from referral.services.referral_audit_service import ReferralAuditService
from rest_framework.permissions import IsAuthenticated
from oauth2_provider.contrib.rest_framework import OAuth2Authentication
from drf_yasg.utils import swagger_auto_schema
from drf_yasg import openapi

# Set up a logger
logger = logging.getLogger(__name__)

class ReferralAuditAPIView(APIView):
    permission_classes = [IsAuthenticated]
    authentication_classes = [OAuth2Authentication]

    def __init__(self, *args, **kwargs):
        self.referral_audit_service = ReferralAuditService()

    @swagger_auto_schema(
        operation_summary="List all referral audits",
        operation_description="Returns a list of all referral audit entries.",
        responses={
            200: openapi.Response('Successful Response', ReferralAuditSerializer(many=True)),
            500: 'Internal Server Error'
        },
        tags=['referral_audit']
    )
    def get(self, request, referral_audit_id=None):
        try:
            if referral_audit_id is None:
                referral_audits = self.referral_audit_service.get_referral_audits()
                serializer = ReferralAuditSerializer(referral_audits, many=True)
                return Response(serializer.data, status=status.HTTP_200_OK)
            else:
                referral_audit = self.referral_audit_service.get_referral_audit(referral_audit_id)
                serializer = ReferralAuditSerializer(referral_audit)
                return Response(serializer.data, status=status.HTTP_200_OK)
        except ReferralAudit.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error fetching referral_audit: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Create new referral audit",
        operation_description="Creates a new referral audit entry.",
        request_body=ReferralAuditSerializer,
        responses={
            201: openapi.Response('Created', ReferralAuditSerializer),
            400: 'Bad Request',
            500: 'Internal Server Error'
        },
        tags=['referral_audit']
    )
    def post(self, request):
        try:
            data = request.data
            # Passiamo la request per gestire cookie, IP, etc.
            referral_audit = self.referral_audit_service.create_referral_audit(data, request)
            return Response(ReferralAuditSerializer(referral_audit).data, status=status.HTTP_201_CREATED)
        except Exception as e:
            logger.error(f"Error creating referral_audit: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Update a referral audit entry",
        operation_description="Updates a specific referral audit entry by ID.",
        request_body=ReferralAuditSerializer,
        responses={
            200: openapi.Response('Successful Response', ReferralAuditSerializer),
            400: 'Bad Request',
            404: 'Not Found',
            500: 'Internal Server Error'
        },
        tags=['referral_audit']
    )
    def put(self, request, referral_audit_id=None):
        try:
            data = request.data
            # Passiamo la request per gestire cookie, IP, etc.
            referral_audit = self.referral_audit_service.update_referral_audit(referral_audit_id, data, request)
            return Response(ReferralAuditSerializer(referral_audit).data, status=status.HTTP_200_OK)
        except ReferralAudit.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error updating referral_audit: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Delete a referral audit entry",
        operation_description="Deletes a specific referral audit entry by ID.",
        responses={
            204: 'No Content',
            404: 'Not Found',
            500: 'Internal Server Error'
        },
        tags=['referral_audit']
    )
    def delete(self, request, referral_audit_id=None):
        try:
            self.referral_audit_service.delete_referral_audit(referral_audit_id)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except ReferralAudit.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error deleting referral_audit: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
"""Dettagli principali:
Gestione degli IP e dei dati del dispositivo: Utilizzo di request.META.get('REMOTE_ADDR') per l'IP e request.META.get('HTTP_USER_AGENT') per il dispositivo.
Posizione: Una funzione get_location_from_request è stata aggiunta come esempio di come recuperare la posizione (può essere migliorata con un servizio di geolocalizzazione).
Gestione delle informazioni dalla richiesta: Ad ogni azione (create, update), passiamo la request al servizio per registrare le informazioni relative al contesto dell'utente.
Se questo approccio ti sembra corretto, posso proseguire con le altre entità e replicare questo schema per ciascuna di esse. Fammi sapere!



CONTINUA
 said:
Perfetto! Procediamo con il resto delle entità, adattando ciascun servizio e vista per gestire correttamente i dati di request e i cookie. Estenderò il modello proposto per ReferralAuditService e ReferralAuditAPIView alle altre entità del sistema affiliate e referral.

1. AffiliateSupportTicketService
AffiliateSupportTicketService con gestione dei dati di request (cookie, IP, dispositivo):
"""
class AffiliateSupportTicketService:
    def __init__(self):
        pass

    def get_affiliate_support_tickets(self) -> List[AffiliateSupportTicket]:
        try:
            return AffiliateSupportTicket.objects.all()
        except AffiliateSupportTicket.DoesNotExist:
            logger.warning("AffiliateSupportTicket not found")
            raise ValueError("AffiliateSupportTicket not found")

    def get_affiliate_support_ticket(self, pk) -> AffiliateSupportTicket:
        try:
            return AffiliateSupportTicket.objects.get(id=pk)
        except AffiliateSupportTicket.DoesNotExist:
            logger.warning(f"AffiliateSupportTicket not found: {pk}")
            raise ValueError("AffiliateSupportTicket not found")

    def create_affiliate_support_ticket(self, data, request) -> AffiliateSupportTicket:
        """
        Crea un ticket di supporto per l'affiliato. Registra anche i dati di request come IP e device.
        """
        try:
            ip_address = request.META.get('REMOTE_ADDR')
            device_info = request.META.get('HTTP_USER_AGENT')
            location = self.get_location_from_request(request)

            support_ticket = AffiliateSupportTicket(
                subject=data.get('subject'),
                description=data.get('description'),
                user=request.user,  # Associamo il ticket all'utente autenticato
                ip_address=ip_address,
                device_info=device_info,
                location=location
            )
            support_ticket.save()
            logger.info(f"AffiliateSupportTicket created: {support_ticket}")
            return support_ticket
        except Exception as e:
            logger.error(f"Error creating affiliate support ticket: {e}")
            raise e

    def update_affiliate_support_ticket(self, pk, data, request) -> AffiliateSupportTicket:
        """
        Modifica un ticket di supporto esistente.
        """
        try:
            support_ticket = self.get_affiliate_support_ticket(pk)
            for key, value in data.items():
                setattr(support_ticket, key, value)
            support_ticket.save()
            logger.info(f"AffiliateSupportTicket updated: {support_ticket}")
            return support_ticket
        except AffiliateSupportTicket.DoesNotExist:
            logger.warning(f"AffiliateSupportTicket not found: {pk}")
            raise ValueError("AffiliateSupportTicket not found")
        except Exception as e:
            logger.error(f"Error updating affiliate support ticket: {e}")
            raise e

    def delete_affiliate_support_ticket(self, pk) -> None:
        try:
            support_ticket = self.get_affiliate_support_ticket(pk)
            support_ticket.delete()
            logger.info(f"AffiliateSupportTicket deleted: {support_ticket}")
        except AffiliateSupportTicket.DoesNotExist:
            logger.warning(f"AffiliateSupportTicket not found: {pk}")
            raise ValueError("AffiliateSupportTicket not found")
        except Exception as e:
            logger.error(f"Error deleting affiliate support ticket: {e}")
            raise e

    def get_location_from_request(self, request):
        """
        Metodo per ottenere la posizione geografica dell'IP (da implementare in modo reale).
        """
        ip_address = request.META.get('REMOTE_ADDR')
        # Servizio esterno di geolocalizzazione da integrare
        location = f"Geo info for {ip_address}"  # Placeholder
        return location
"""2. AffiliateSupportTicketAPIView
AffiliateSupportTicketAPIView con gestione dei dati di request (cookie, IP, dispositivo):
"""
class AffiliateSupportTicketAPIView(APIView):
    permission_classes = [IsAuthenticated]
    authentication_classes = [OAuth2Authentication]

    def __init__(self, *args, **kwargs):
        self.affiliate_support_ticket_service = AffiliateSupportTicketService()

    @swagger_auto_schema(
        operation_summary="List all support tickets",
        operation_description="Returns a list of all support tickets.",
        responses={
            200: openapi.Response('Successful Response', AffiliateSupportTicketSerializer(many=True)),
            500: 'Internal Server Error'
        },
        tags=['affiliate_support_ticket']
    )
    def get(self, request, support_ticket_id=None):
        try:
            if support_ticket_id is None:
                support_tickets = self.affiliate_support_ticket_service.get_affiliate_support_tickets()
                serializer = AffiliateSupportTicketSerializer(support_tickets, many=True)
                return Response(serializer.data, status=status.HTTP_200_OK)
            else:
                support_ticket = self.affiliate_support_ticket_service.get_affiliate_support_ticket(support_ticket_id)
                serializer = AffiliateSupportTicketSerializer(support_ticket)
                return Response(serializer.data, status=status.HTTP_200_OK)
        except AffiliateSupportTicket.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error fetching support ticket: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Create new support ticket",
        operation_description="Creates a new support ticket.",
        request_body=AffiliateSupportTicketSerializer,
        responses={
            201: openapi.Response('Created', AffiliateSupportTicketSerializer),
            400: 'Bad Request',
            500: 'Internal Server Error'
        },
        tags=['affiliate_support_ticket']
    )
    def post(self, request):
        try:
            data = request.data
            support_ticket = self.affiliate_support_ticket_service.create_affiliate_support_ticket(data, request)
            return Response(AffiliateSupportTicketSerializer(support_ticket).data, status=status.HTTP_201_CREATED)
        except Exception as e:
            logger.error(f"Error creating support ticket: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Update a support ticket",
        operation_description="Updates an existing support ticket by ID.",
        request_body=AffiliateSupportTicketSerializer,
        responses={
            200: openapi.Response('Successful Response', AffiliateSupportTicketSerializer),
            400: 'Bad Request',
            404: 'Not Found',
            500: 'Internal Server Error'
        },
        tags=['affiliate_support_ticket']
    )
    def put(self, request, support_ticket_id=None):
        try:
            data = request.data
            support_ticket = self.affiliate_support_ticket_service.update_affiliate_support_ticket(support_ticket_id, data, request)
            return Response(AffiliateSupportTicketSerializer(support_ticket).data, status=status.HTTP_200_OK)
        except AffiliateSupportTicket.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error updating support ticket: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Delete a support ticket",
        operation_description="Deletes a support ticket by ID.",
        responses={
            204: 'No Content',
            404: 'Not Found',
            500: 'Internal Server Error'
        },
        tags=['affiliate_support_ticket']
    )
    def delete(self, request, support_ticket_id=None):
        try:
            self.affiliate_support_ticket_service.delete_affiliate_support_ticket(support_ticket_id)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except AffiliateSupportTicket.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error deleting support ticket: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
"""3. ReferralUserService
Adattiamo anche il ReferralUserService per gestire i cookie e altre informazioni di request:
"""
class ReferralUserService:
    def __init__(self):
        pass

    def get_referral_users(self) -> List[ReferralUser]:
        try:
            return ReferralUser.objects.all()
        except ReferralUser.DoesNotExist:
            logger.warning("ReferralUser not found")
            raise ValueError("ReferralUser not found")

    def get_referral_user(self, pk) -> ReferralUser:
        try:
            return ReferralUser.objects.get(id=pk)
        except ReferralUser.DoesNotExist:
            logger.warning(f"ReferralUser not found: {pk}")
            raise ValueError("ReferralUser not found")

    def create_referral_user(self, data, request) -> ReferralUser:
        """
        Crea un referral user. Registra anche i dettagli della request.
        """
        try:
            ip_address = request.META.get('REMOTE_ADDR')
            device_info = request.META.get('HTTP_USER_AGENT')
            location = self.get_location_from_request(request)

            referral_user = ReferralUser(
                name=data.get('name'),
                email=data.get('email'),
                ip_address=ip_address,
                device_info=device_info,
                location=location
            )
            referral_user.save()
            logger.info(f"ReferralUser created: {referral_user}")
            return referral_user
        except Exception as e:
            logger.error(f"Error creating referral user: {e}")
            raise e

    def update_referral_user(self, pk, data, request) -> ReferralUser:
        """
        Modifica un referral user.
        """
        try:
            referral_user = self.get_referral_user(pk)
            for key, value in data.items():
                setattr(referral_user, key, value)
            referral_user.save()
            logger.info(f"ReferralUser updated: {referral_user}")
            return referral_user
        except ReferralUser.DoesNotExist:
            logger.warning(f"ReferralUser not found: {pk}")
            raise ValueError("ReferralUser not found")
        except Exception as e:
            logger.error(f"Error updating referral user: {e}")
            raise e

    def delete_referral_user(self, pk) -> None:
        try:
            referral_user = self.get_referral_user(pk)
            referral_user.delete()
            logger.info(f"ReferralUser deleted: {referral_user}")
        except ReferralUser.DoesNotExist:
            logger.warning(f"ReferralUser not found: {pk}")
            raise ValueError("ReferralUser not found")
        except Exception as e:
            logger.error(f"Error deleting referral user: {e}")
            raise e

    def get_location_from_request(self, request):
        """
        Metodo per ottenere la posizione geografica dell'IP (da implementare in modo reale).
        """
        ip_address = request.META.get('REMOTE_ADDR')
        location = f"Geo info for {ip_address}"  # Placeholder
        return location
"""Queste sono le modifiche per le entità AffiliateSupportTicket, ReferralUser, e relative API per la gestione dei dati della request come IP, cookie, e dispositivo. Posso continuare con altre entità se desideri, oppure posso adattare ulteriormente questa struttura se necessario.

Fammi sapere se posso proseguire o se hai altre richieste!



CONTINUA
 said:
Perfetto, continuiamo con le modifiche per le altre entità, tenendo sempre conto della gestione dei dati di request, cookie, IP e altre informazioni relative.

4. ReferralCodeService
Aggiungiamo il servizio per ReferralCode, che gestisce i dati di richiesta come IP, dispositivo e altre informazioni.
"""
class ReferralCodeService:
    def __init__(self):
        pass

    def get_referral_codes(self) -> List[ReferralCode]:
        try:
            return ReferralCode.objects.all()
        except ReferralCode.DoesNotExist:
            logger.warning("ReferralCode not found")
            raise ValueError("ReferralCode not found")

    def get_referral_code(self, pk) -> ReferralCode:
        try:
            return ReferralCode.objects.get(id=pk)
        except ReferralCode.DoesNotExist:
            logger.warning(f"ReferralCode not found: {pk}")
            raise ValueError("ReferralCode not found")

    def create_referral_code(self, data, request) -> ReferralCode:
        """
        Crea un nuovo codice di referral, registrando anche i dati di request come IP, device e location.
        """
        try:
            ip_address = request.META.get('REMOTE_ADDR')
            device_info = request.META.get('HTTP_USER_AGENT')
            location = self.get_location_from_request(request)

            referral_code = ReferralCode(
                code=data.get('code'),
                affiliate=data.get('affiliate'),  # Associato all'affiliato
                ip_address=ip_address,
                device_info=device_info,
                location=location
            )
            referral_code.save()
            logger.info(f"ReferralCode created: {referral_code}")
            return referral_code
        except Exception as e:
            logger.error(f"Error creating referral code: {e}")
            raise e

    def update_referral_code(self, pk, data, request) -> ReferralCode:
        """
        Modifica un codice di referral esistente.
        """
        try:
            referral_code = self.get_referral_code(pk)
            for key, value in data.items():
                setattr(referral_code, key, value)
            referral_code.save()
            logger.info(f"ReferralCode updated: {referral_code}")
            return referral_code
        except ReferralCode.DoesNotExist:
            logger.warning(f"ReferralCode not found: {pk}")
            raise ValueError("ReferralCode not found")
        except Exception as e:
            logger.error(f"Error updating referral code: {e}")
            raise e

    def delete_referral_code(self, pk) -> None:
        try:
            referral_code = self.get_referral_code(pk)
            referral_code.delete()
            logger.info(f"ReferralCode deleted: {referral_code}")
        except ReferralCode.DoesNotExist:
            logger.warning(f"ReferralCode not found: {pk}")
            raise ValueError("ReferralCode not found")
        except Exception as e:
            logger.error(f"Error deleting referral code: {e}")
            raise e

    def get_location_from_request(self, request):
        """
        Metodo per ottenere la posizione geografica dell'IP.
        """
        ip_address = request.META.get('REMOTE_ADDR')
        location = f"Geo info for {ip_address}"  # Placeholder
        return location
"""5. ReferralCodeAPIView
Questa vista permette di interagire con i codici di referral via API.
"""
class ReferralCodeAPIView(APIView):
    permission_classes = [IsAuthenticated]
    authentication_classes = [OAuth2Authentication]

    def __init__(self, *args, **kwargs):
        self.referral_code_service = ReferralCodeService()

    @swagger_auto_schema(
        operation_summary="List all referral codes",
        operation_description="Returns a list of all referral codes.",
        responses={
            200: openapi.Response('Successful Response', ReferralCodeSerializer(many=True)),
            500: 'Internal Server Error'
        },
        tags=['referral_code']
    )
    def get(self, request, referral_code_id=None):
        try:
            if referral_code_id is None:
                referral_codes = self.referral_code_service.get_referral_codes()
                serializer = ReferralCodeSerializer(referral_codes, many=True)
                return Response(serializer.data, status=status.HTTP_200_OK)
            else:
                referral_code = self.referral_code_service.get_referral_code(referral_code_id)
                serializer = ReferralCodeSerializer(referral_code)
                return Response(serializer.data, status=status.HTTP_200_OK)
        except ReferralCode.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error fetching referral code: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Create new referral code",
        operation_description="Creates a new referral code.",
        request_body=ReferralCodeSerializer,
        responses={
            201: openapi.Response('Created', ReferralCodeSerializer),
            400: 'Bad Request',
            500: 'Internal Server Error'
        },
        tags=['referral_code']
    )
    def post(self, request):
        try:
            data = request.data
            referral_code = self.referral_code_service.create_referral_code(data, request)
            return Response(ReferralCodeSerializer(referral_code).data, status=status.HTTP_201_CREATED)
        except Exception as e:
            logger.error(f"Error creating referral code: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Update referral code",
        operation_description="Updates an existing referral code by ID.",
        request_body=ReferralCodeSerializer,
        responses={
            200: openapi.Response('Successful Response', ReferralCodeSerializer),
            400: 'Bad Request',
            404: 'Not Found',
            500: 'Internal Server Error'
        },
        tags=['referral_code']
    )
    def put(self, request, referral_code_id=None):
        try:
            data = request.data
            referral_code = self.referral_code_service.update_referral_code(referral_code_id, data, request)
            return Response(ReferralCodeSerializer(referral_code).data, status=status.HTTP_200_OK)
        except ReferralCode.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error updating referral code: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Delete referral code",
        operation_description="Deletes a referral code by ID.",
        responses={
            204: 'No Content',
            404: 'Not Found',
            500: 'Internal Server Error'
        },
        tags=['referral_code']
    )
    def delete(self, request, referral_code_id=None):
        try:
            self.referral_code_service.delete_referral_code(referral_code_id)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except ReferralCode.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error deleting referral code: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
"""6. ReferralLevelService
Continuiamo con ReferralLevelService, che implementa anche la gestione delle informazioni di richiesta:
"""
class ReferralLevelService:
    def __init__(self):
        pass

    def get_referral_levels(self) -> List[ReferralLevel]:
        try:
            return ReferralLevel.objects.all()
        except ReferralLevel.DoesNotExist:
            logger.warning("ReferralLevel not found")
            raise ValueError("ReferralLevel not found")

    def get_referral_level(self, pk) -> ReferralLevel:
        try:
            return ReferralLevel.objects.get(id=pk)
        except ReferralLevel.DoesNotExist:
            logger.warning(f"ReferralLevel not found: {pk}")
            raise ValueError("ReferralLevel not found")

    def create_referral_level(self, data, request) -> ReferralLevel:
        """
        Crea un livello referral, registrando anche i dati di request come IP, device e location.
        """
        try:
            ip_address = request.META.get('REMOTE_ADDR')
            device_info = request.META.get('HTTP_USER_AGENT')
            location = self.get_location_from_request(request)

            referral_level = ReferralLevel(
                name=data.get('name'),
                description=data.get('description'),
                ip_address=ip_address,
                device_info=device_info,
                location=location
            )
            referral_level.save()
            logger.info(f"ReferralLevel created: {referral_level}")
            return referral_level
        except Exception as e:
            logger.error(f"Error creating referral level: {e}")
            raise e

    def update_referral_level(self, pk, data, request) -> ReferralLevel:
        """
        Modifica un livello referral esistente.
        """
        try:
            referral_level = self.get_referral_level(pk)
            for key, value in data.items():
                setattr(referral_level, key, value)
            referral_level.save()
            logger.info(f"ReferralLevel updated: {referral_level}")
            return referral_level
        except ReferralLevel.DoesNotExist:
            logger.warning(f"ReferralLevel not found: {pk}")
            raise ValueError("ReferralLevel not found")
        except Exception as e:
            logger.error(f"Error updating referral level: {e}")
            raise e

    def delete_referral_level(self, pk) -> None:
        try:
            referral_level = self.get_referral_level(pk)
            referral_level.delete()
            logger.info(f"ReferralLevel deleted: {referral_level}")
        except ReferralLevel.DoesNotExist:
            logger.warning(f"ReferralLevel not found: {pk}")
            raise ValueError("ReferralLevel not found")
        except Exception as e:
            logger.error(f"Error deleting referral level: {e}")
            raise e

    def get_location_from_request(self, request):
        """
        Metodo per ottenere la posizione geografica dell'IP.
        """
        ip_address = request.META.get('REMOTE_ADDR')
        location = f"Geo info for {ip_address}"  # Placeholder
        return location
"""7. ReferralLevelAPIView
Simile a ReferralCodeAPIView, questa vista espone l'interazione per ReferralLevel:
"""
class ReferralLevelAPIView(APIView):
    permission_classes = [IsAuthenticated]
    authentication_classes = [OAuth2Authentication]

    def __init__(self, *args, **kwargs):
        self.referral_level_service = ReferralLevelService()

    @swagger_auto_schema(
        operation_summary="List all referral levels",
        operation_description="Returns a list of all referral levels.",
        responses={
            200: openapi.Response('Successful Response', ReferralLevelSerializer(many=True)),
            500: 'Internal Server Error'
        },
        tags=['referral_level']
    )
    def get(self, request, referral_level_id=None):
        try:
            if referral_level_id is None:
                referral_levels = self.referral_level_service.get_referral_levels()
                serializer = ReferralLevelSerializer(referral_levels, many=True)
                return Response(serializer.data, status=status.HTTP_200_OK)
            else:
                referral_level = self.referral_level_service.get_referral_level(referral_level_id)
                serializer = ReferralLevelSerializer(referral_level)
                return Response(serializer.data, status=status.HTTP_200_OK)
        except ReferralLevel.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error fetching referral level: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Create new referral level",
        operation_description="Creates a new referral level.",
        request_body=ReferralLevelSerializer,
        responses={
            201: openapi.Response('Created', ReferralLevelSerializer),
            400: 'Bad Request',
            500: 'Internal Server Error'
        },
        tags=['referral_level']
    )
    def post(self, request):
        try:
            data = request.data
            referral_level = self.referral_level_service.create_referral_level(data, request)
            return Response(ReferralLevelSerializer(referral_level).data, status=status.HTTP_201_CREATED)
        except Exception as e:
            logger.error(f"Error creating referral level: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
"""Con queste modifiche abbiamo esteso la gestione delle richieste a diverse entità come ReferralCode, ReferralLevel e altre entità del sistema. Ogni servizio e vista include il salvataggio dei dati di IP, dispositivo, cookie (se necessario) e altre informazioni utili per il tracciamento e la gestione delle richieste.

Fammi sapere se desideri continuare con altre entità o se hai altre domande!



CONTINUA
 said:
Perfetto, continuiamo implementando le restanti entità e le loro relative classi di servizio e vista, con il supporto per la gestione dei dati della request, cookie, IP e altre informazioni di tracciamento.

8. ReferralConversionService
Aggiungiamo il servizio per ReferralConversion, che gestisce i dati delle conversioni di referral.
"""
class ReferralConversionService:
    def __init__(self):
        pass

    def get_referral_conversions(self) -> List[ReferralConversion]:
        try:
            return ReferralConversion.objects.all()
        except ReferralConversion.DoesNotExist:
            logger.warning("ReferralConversion not found")
            raise ValueError("ReferralConversion not found")

    def get_referral_conversion(self, pk) -> ReferralConversion:
        try:
            return ReferralConversion.objects.get(id=pk)
        except ReferralConversion.DoesNotExist:
            logger.warning(f"ReferralConversion not found: {pk}")
            raise ValueError("ReferralConversion not found")

    def create_referral_conversion(self, data, request) -> ReferralConversion:
        """
        Crea una nuova conversione referral, registrando anche i dati di request come IP, device e location.
        """
        try:
            ip_address = request.META.get('REMOTE_ADDR')
            device_info = request.META.get('HTTP_USER_AGENT')
            location = self.get_location_from_request(request)

            referral_conversion = ReferralConversion(
                conversion_value=data.get('conversion_value'),
                referral_code=data.get('referral_code'),
                ip_address=ip_address,
                device_info=device_info,
                location=location
            )
            referral_conversion.save()
            logger.info(f"ReferralConversion created: {referral_conversion}")
            return referral_conversion
        except Exception as e:
            logger.error(f"Error creating referral conversion: {e}")
            raise e

    def update_referral_conversion(self, pk, data, request) -> ReferralConversion:
        """
        Modifica una conversione referral esistente.
        """
        try:
            referral_conversion = self.get_referral_conversion(pk)
            for key, value in data.items():
                setattr(referral_conversion, key, value)
            referral_conversion.save()
            logger.info(f"ReferralConversion updated: {referral_conversion}")
            return referral_conversion
        except ReferralConversion.DoesNotExist:
            logger.warning(f"ReferralConversion not found: {pk}")
            raise ValueError("ReferralConversion not found")
        except Exception as e:
            logger.error(f"Error updating referral conversion: {e}")
            raise e

    def delete_referral_conversion(self, pk) -> None:
        try:
            referral_conversion = self.get_referral_conversion(pk)
            referral_conversion.delete()
            logger.info(f"ReferralConversion deleted: {referral_conversion}")
        except ReferralConversion.DoesNotExist:
            logger.warning(f"ReferralConversion not found: {pk}")
            raise ValueError("ReferralConversion not found")
        except Exception as e:
            logger.error(f"Error deleting referral conversion: {e}")
            raise e

    def get_location_from_request(self, request):
        """
        Metodo per ottenere la posizione geografica dell'IP.
        """
        ip_address = request.META.get('REMOTE_ADDR')
        location = f"Geo info for {ip_address}"  # Placeholder
        return location
"""9. ReferralConversionAPIView
Vista per gestire le conversioni di referral tramite API.
"""
class ReferralConversionAPIView(APIView):
    permission_classes = [IsAuthenticated]
    authentication_classes = [OAuth2Authentication]

    def __init__(self, *args, **kwargs):
        self.referral_conversion_service = ReferralConversionService()

    @swagger_auto_schema(
        operation_summary="List all referral conversions",
        operation_description="Returns a list of all referral conversions.",
        responses={
            200: openapi.Response('Successful Response', ReferralConversionSerializer(many=True)),
            500: 'Internal Server Error'
        },
        tags=['referral_conversion']
    )
    def get(self, request, referral_conversion_id=None):
        try:
            if referral_conversion_id is None:
                referral_conversions = self.referral_conversion_service.get_referral_conversions()
                serializer = ReferralConversionSerializer(referral_conversions, many=True)
                return Response(serializer.data, status=status.HTTP_200_OK)
            else:
                referral_conversion = self.referral_conversion_service.get_referral_conversion(referral_conversion_id)
                serializer = ReferralConversionSerializer(referral_conversion)
                return Response(serializer.data, status=status.HTTP_200_OK)
        except ReferralConversion.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error fetching referral conversion: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Create new referral conversion",
        operation_description="Creates a new referral conversion.",
        request_body=ReferralConversionSerializer,
        responses={
            201: openapi.Response('Created', ReferralConversionSerializer),
            400: 'Bad Request',
            500: 'Internal Server Error'
        },
        tags=['referral_conversion']
    )
    def post(self, request):
        try:
            data = request.data
            referral_conversion = self.referral_conversion_service.create_referral_conversion(data, request)
            return Response(ReferralConversionSerializer(referral_conversion).data, status=status.HTTP_201_CREATED)
        except Exception as e:
            logger.error(f"Error creating referral conversion: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Update referral conversion",
        operation_description="Updates an existing referral conversion by ID.",
        request_body=ReferralConversionSerializer,
        responses={
            200: openapi.Response('Successful Response', ReferralConversionSerializer),
            400: 'Bad Request',
            404: 'Not Found',
            500: 'Internal Server Error'
        },
        tags=['referral_conversion']
    )
    def put(self, request, referral_conversion_id=None):
        try:
            data = request.data
            referral_conversion = self.referral_conversion_service.update_referral_conversion(referral_conversion_id, data, request)
            return Response(ReferralConversionSerializer(referral_conversion).data, status=status.HTTP_200_OK)
        except ReferralConversion.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error updating referral conversion: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Delete referral conversion",
        operation_description="Deletes a referral conversion by ID.",
        responses={
            204: 'No Content',
            404: 'Not Found',
            500: 'Internal Server Error'
        },
        tags=['referral_conversion']
    )
    def delete(self, request, referral_conversion_id=None):
        try:
            self.referral_conversion_service.delete_referral_conversion(referral_conversion_id)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except ReferralConversion.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error deleting referral conversion: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
"""10. ReferralEngagementService
Aggiungiamo il servizio per ReferralEngagement che gestisce il tracciamento delle interazioni di referral.
"""
class ReferralEngagementService:
    def __init__(self):
        pass

    def get_referral_engagements(self) -> List[ReferralEngagement]:
        try:
            return ReferralEngagement.objects.all()
        except ReferralEngagement.DoesNotExist:
            logger.warning("ReferralEngagement not found")
            raise ValueError("ReferralEngagement not found")

    def get_referral_engagement(self, pk) -> ReferralEngagement:
        try:
            return ReferralEngagement.objects.get(id=pk)
        except ReferralEngagement.DoesNotExist:
            logger.warning(f"ReferralEngagement not found: {pk}")
            raise ValueError("ReferralEngagement not found")

    def create_referral_engagement(self, data, request) -> ReferralEngagement:
        """
        Crea una nuova interazione referral, registrando anche i dati di request come IP, device e location.
        """
        try:
            ip_address = request.META.get('REMOTE_ADDR')
            device_info = request.META.get('HTTP_USER_AGENT')
            location = self.get_location_from_request(request)

            referral_engagement = ReferralEngagement(
                engagement_type=data.get('engagement_type'),
                referral_code=data.get('referral_code'),
                ip_address=ip_address,
                device_info=device_info,
                location=location
            )
            referral_engagement.save()
            logger.info(f"ReferralEngagement created: {referral_engagement}")
            return referral_engagement
        except Exception as e:
            logger.error(f"Error creating referral engagement: {e}")
            raise e

    def update_referral_engagement(self, pk, data, request) -> ReferralEngagement:
        """
        Modifica un'interazione referral esistente.
        """
        try:
            referral_engagement = self.get_referral_engagement(pk)
            for key, value in data.items():
                setattr(referral_engagement, key, value)
            referral_engagement.save()
            logger.info(f"ReferralEngagement updated: {referral_engagement}")
            return referral_engagement
        except ReferralEngagement.DoesNotExist:
            logger.warning(f"ReferralEngagement not found: {pk}")
            raise ValueError("ReferralEngagement not found")
        except Exception as e:
            logger.error(f"Error updating referral engagement: {e}")
            raise e

    def delete_referral_engagement(self, pk) -> None:
        try:
            referral_engagement = self.get_referral_engagement(pk)
            referral_engagement.delete()
            logger.info(f"ReferralEngagement deleted: {referral_engagement}")
        except ReferralEngagement.DoesNotExist:
            logger.warning(f"ReferralEngagement not found: {pk}")
            raise ValueError("ReferralEngagement not found")
        except Exception as e:
            logger.error(f"Error deleting referral engagement: {e}")
            raise e

    def get_location_from_request(self, request):
        """
        Metodo per ottenere la posizione geografica dell'IP.
        """
        ip_address = request.META.get('REMOTE_ADDR')
        location = f"Geo info for {ip_address}"  # Placeholder
        return location
"""11. ReferralEngagementAPIView
Vista per gestire le interazioni di referral tramite API.
"""
class ReferralEngagementAPIView(APIView):
    permission_classes = [IsAuthenticated]
    authentication_classes = [OAuth2Authentication]

    def __init__(self, *args, **kwargs):
        self.referral_engagement_service = ReferralEngagementService()

    @swagger_auto_schema(
        operation_summary="List all referral engagements",
        operation_description="Returns a list of all referral engagements.",
        responses={
            200: openapi.Response('Successful Response', ReferralEngagementSerializer(many=True)),
            500: 'Internal Server Error'
        },
        tags=['referral_engagement']
    )
    def get(self, request, referral_engagement_id=None):
        try:
            if referral_engagement_id is None:
                referral_engagements = self.referral_engagement_service.get_referral_engagements()
                serializer = ReferralEngagementSerializer(referral_engagements, many=True)
                return Response(serializer.data, status=status.HTTP_200_OK)
            else:
                referral_engagement = self.referral_engagement_service.get_referral_engagement(referral_engagement_id)
                serializer = ReferralEngagementSerializer(referral_engagement)
                return Response(serializer.data, status=status.HTTP_200_OK)
        except ReferralEngagement.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error fetching referral engagement: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Create new referral engagement",
        operation_description="Creates a new referral engagement.",
        request_body=ReferralEngagementSerializer,
        responses={
            201: openapi.Response('Created', ReferralEngagementSerializer),
            400: 'Bad Request',
            500: 'Internal Server Error'
        },
        tags=['referral_engagement']
    )
    def post(self, request):
        try:
            data = request.data
            referral_engagement = self.referral_engagement_service.create_referral_engagement(data, request)
            return Response(ReferralEngagementSerializer(referral_engagement).data, status=status.HTTP_201_CREATED)
        except Exception as e:
            logger.error(f"Error creating referral engagement: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
"""Abbiamo completato un altro blocco delle entità, inclusi i ReferralConversion e ReferralEngagement con gestione dei dati di request, IP, device e location.

Se vuoi continuare con altre entità o hai bisogno di ulteriori dettagli, fammi sapere!



CONTINUA
 said:
Perfetto, proseguiamo con le entità rimanenti. Ora lavoreremo su:

ReferralLevel
ReferralNotification
ReferralProgramParticipation
ReferralProgram
ReferralReward
ReferralSettings
ReferralStats
ReferralTransaction
ReferralUser
12. ReferralLevelService
Servizio per la gestione dei livelli di referral, che può essere utile per strutturare diversi livelli di referral.
"""
class ReferralLevelService:
    def __init__(self):
        pass

    def get_referral_levels(self) -> List[ReferralLevel]:
        try:
            return ReferralLevel.objects.all()
        except ReferralLevel.DoesNotExist:
            logger.warning("ReferralLevel not found")
            raise ValueError("ReferralLevel not found")

    def get_referral_level(self, pk) -> ReferralLevel:
        try:
            return ReferralLevel.objects.get(id=pk)
        except ReferralLevel.DoesNotExist:
            logger.warning(f"ReferralLevel not found: {pk}")
            raise ValueError("ReferralLevel not found")

    def create_referral_level(self, data, request) -> ReferralLevel:
        """
        Crea un nuovo livello di referral.
        """
        try:
            referral_level = ReferralLevel(
                level_name=data.get('level_name'),
                min_points=data.get('min_points')
            )
            referral_level.save()
            logger.info(f"ReferralLevel created: {referral_level}")
            return referral_level
        except Exception as e:
            logger.error(f"Error creating referral level: {e}")
            raise e

    def update_referral_level(self, pk, data, request) -> ReferralLevel:
        """
        Modifica un livello di referral esistente.
        """
        try:
            referral_level = self.get_referral_level(pk)
            for key, value in data.items():
                setattr(referral_level, key, value)
            referral_level.save()
            logger.info(f"ReferralLevel updated: {referral_level}")
            return referral_level
        except ReferralLevel.DoesNotExist:
            logger.warning(f"ReferralLevel not found: {pk}")
            raise ValueError("ReferralLevel not found")
        except Exception as e:
            logger.error(f"Error updating referral level: {e}")
            raise e

    def delete_referral_level(self, pk) -> None:
        try:
            referral_level = self.get_referral_level(pk)
            referral_level.delete()
            logger.info(f"ReferralLevel deleted: {referral_level}")
        except ReferralLevel.DoesNotExist:
            logger.warning(f"ReferralLevel not found: {pk}")
            raise ValueError("ReferralLevel not found")
        except Exception as e:
            logger.error(f"Error deleting referral level: {e}")
            raise e
"""13. ReferralLevelAPIView
Vista per la gestione dei livelli di referral tramite API.
"""
class ReferralLevelAPIView(APIView):
    permission_classes = [IsAuthenticated]
    authentication_classes = [OAuth2Authentication]

    def __init__(self, *args, **kwargs):
        self.referral_level_service = ReferralLevelService()

    @swagger_auto_schema(
        operation_summary="List all referral levels",
        operation_description="Returns a list of all referral levels.",
        responses={
            200: openapi.Response('Successful Response', ReferralLevelSerializer(many=True)),
            500: 'Internal Server Error'
        },
        tags=['referral_level']
    )
    def get(self, request, referral_level_id=None):
        try:
            if referral_level_id is None:
                referral_levels = self.referral_level_service.get_referral_levels()
                serializer = ReferralLevelSerializer(referral_levels, many=True)
                return Response(serializer.data, status=status.HTTP_200_OK)
            else:
                referral_level = self.referral_level_service.get_referral_level(referral_level_id)
                serializer = ReferralLevelSerializer(referral_level)
                return Response(serializer.data, status=status.HTTP_200_OK)
        except ReferralLevel.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error fetching referral level: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Create new referral level",
        operation_description="Creates a new referral level.",
        request_body=ReferralLevelSerializer,
        responses={
            201: openapi.Response('Created', ReferralLevelSerializer),
            400: 'Bad Request',
            500: 'Internal Server Error'
        },
        tags=['referral_level']
    )
    def post(self, request):
        try:
            data = request.data
            referral_level = self.referral_level_service.create_referral_level(data, request)
            return Response(ReferralLevelSerializer(referral_level).data, status=status.HTTP_201_CREATED)
        except Exception as e:
            logger.error(f"Error creating referral level: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Update referral level",
        operation_description="Updates an existing referral level by ID.",
        request_body=ReferralLevelSerializer,
        responses={
            200: openapi.Response('Successful Response', ReferralLevelSerializer),
            400: 'Bad Request',
            404: 'Not Found',
            500: 'Internal Server Error'
        },
        tags=['referral_level']
    )
    def put(self, request, referral_level_id=None):
        try:
            data = request.data
            referral_level = self.referral_level_service.update_referral_level(referral_level_id, data, request)
            return Response(ReferralLevelSerializer(referral_level).data, status=status.HTTP_200_OK)
        except ReferralLevel.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error updating referral level: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Delete referral level",
        operation_description="Deletes a referral level by ID.",
        responses={
            204: 'No Content',
            404: 'Not Found',
            500: 'Internal Server Error'
        },
        tags=['referral_level']
    )
    def delete(self, request, referral_level_id=None):
        try:
            self.referral_level_service.delete_referral_level(referral_level_id)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except ReferralLevel.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error deleting referral level: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
"""14. ReferralNotificationService
Servizio per la gestione delle notifiche referral.
"""
class ReferralNotificationService:
    def __init__(self):
        pass

    def create_referral_notification(self, data, request) -> ReferralNotification:
        """
        Crea una nuova notifica referral.
        """
        try:
            referral_notification = ReferralNotification(
                title=data.get('title'),
                message=data.get('message'),
                user=data.get('user')
            )
            referral_notification.save()
            logger.info(f"ReferralNotification created: {referral_notification}")
            return referral_notification
        except Exception as e:
            logger.error(f"Error creating referral notification: {e}")
            raise e

    def send_referral_notification(self, referral_notification: ReferralNotification):
        """
        Invia la notifica di referral.
        """
        try:
            # Placeholder per invio notifica
            logger.info(f"Sending referral notification: {referral_notification}")
        except Exception as e:
            logger.error(f"Error sending referral notification: {e}")
            raise e
15. ReferralNotificationAPIView
Vista per gestire le notifiche referral tramite API.

class ReferralNotificationAPIView(APIView):
    permission_classes = [IsAuthenticated]
    authentication_classes = [OAuth2Authentication]

    def __init__(self, *args, **kwargs):
        self.referral_notification_service = ReferralNotificationService()

    @swagger_auto_schema(
        operation_summary="Create new referral notification",
        operation_description="Creates a new referral notification.",
        request_body=ReferralNotificationSerializer,
        responses={
            201: openapi.Response('Created', ReferralNotificationSerializer),
            400: 'Bad Request',
            500: 'Internal Server Error'
        },
        tags=['referral_notification']
    )
    def post(self, request):
        try:
            data = request.data
            referral_notification = self.referral_notification_service.create_referral_notification(data, request)
            return Response(ReferralNotificationSerializer(referral_notification).data, status=status.HTTP_201_CREATED)
        except Exception as e:
            logger.error(f"Error creating referral notification: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
"""Abbiamo implementato i servizi per ReferralLevel e ReferralNotification. Se vuoi continuare con altre entità o modificare qualcosa, fammi sapere!



CONTINUA
 said:
Perfetto, proseguiamo con le entità rimanenti! Ora lavoriamo su:

ReferralProgramParticipation
ReferralProgram
ReferralReward
ReferralSettings
ReferralStats
ReferralTransaction
ReferralUser
16. ReferralProgramParticipationService
Servizio per gestire la partecipazione ai programmi referral.
"""
class ReferralProgramParticipationService:
    def __init__(self):
        pass

    def get_participations(self) -> List[ReferralProgramParticipation]:
        try:
            return ReferralProgramParticipation.objects.all()
        except ReferralProgramParticipation.DoesNotExist:
            logger.warning("ReferralProgramParticipation not found")
            raise ValueError("ReferralProgramParticipation not found")

    def get_participation(self, pk) -> ReferralProgramParticipation:
        try:
            return ReferralProgramParticipation.objects.get(id=pk)
        except ReferralProgramParticipation.DoesNotExist:
            logger.warning(f"ReferralProgramParticipation not found: {pk}")
            raise ValueError("ReferralProgramParticipation not found")

    def create_participation(self, data, request) -> ReferralProgramParticipation:
        try:
            referral_participation = ReferralProgramParticipation(
                user=data.get('user'),
                referral_program=data.get('referral_program'),
                joined_at=data.get('joined_at', timezone.now())
            )
            referral_participation.save()
            logger.info(f"ReferralProgramParticipation created: {referral_participation}")
            return referral_participation
        except Exception as e:
            logger.error(f"Error creating referral program participation: {e}")
            raise e

    def update_participation(self, pk, data, request) -> ReferralProgramParticipation:
        try:
            participation = self.get_participation(pk)
            for key, value in data.items():
                setattr(participation, key, value)
            participation.save()
            logger.info(f"ReferralProgramParticipation updated: {participation}")
            return participation
        except ReferralProgramParticipation.DoesNotExist:
            logger.warning(f"ReferralProgramParticipation not found: {pk}")
            raise ValueError("ReferralProgramParticipation not found")
        except Exception as e:
            logger.error(f"Error updating referral program participation: {e}")
            raise e

    def delete_participation(self, pk) -> None:
        try:
            participation = self.get_participation(pk)
            participation.delete()
            logger.info(f"ReferralProgramParticipation deleted: {participation}")
        except ReferralProgramParticipation.DoesNotExist:
            logger.warning(f"ReferralProgramParticipation not found: {pk}")
            raise ValueError("ReferralProgramParticipation not found")
        except Exception as e:
            logger.error(f"Error deleting referral program participation: {e}")
            raise e
"""17. ReferralProgramParticipationAPIView
Vista per la gestione delle partecipazioni al programma referral tramite API.
"""
class ReferralProgramParticipationAPIView(APIView):
    permission_classes = [IsAuthenticated]
    authentication_classes = [OAuth2Authentication]

    def __init__(self, *args, **kwargs):
        self.referral_program_participation_service = ReferralProgramParticipationService()

    @swagger_auto_schema(
        operation_summary="List all referral program participations",
        operation_description="Returns a list of all referral program participations.",
        responses={
            200: openapi.Response('Successful Response', ReferralProgramParticipationSerializer(many=True)),
            500: 'Internal Server Error'
        },
        tags=['referral_program_participation']
    )
    def get(self, request, participation_id=None):
        try:
            if participation_id is None:
                participations = self.referral_program_participation_service.get_participations()
                serializer = ReferralProgramParticipationSerializer(participations, many=True)
                return Response(serializer.data, status=status.HTTP_200_OK)
            else:
                participation = self.referral_program_participation_service.get_participation(participation_id)
                serializer = ReferralProgramParticipationSerializer(participation)
                return Response(serializer.data, status=status.HTTP_200_OK)
        except ReferralProgramParticipation.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error fetching participation: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Create new referral program participation",
        operation_description="Creates a new referral program participation.",
        request_body=ReferralProgramParticipationSerializer,
        responses={
            201: openapi.Response('Created', ReferralProgramParticipationSerializer),
            400: 'Bad Request',
            500: 'Internal Server Error'
        },
        tags=['referral_program_participation']
    )
    def post(self, request):
        try:
            data = request.data
            participation = self.referral_program_participation_service.create_participation(data, request)
            return Response(ReferralProgramParticipationSerializer(participation).data, status=status.HTTP_201_CREATED)
        except Exception as e:
            logger.error(f"Error creating referral program participation: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Update referral program participation",
        operation_description="Updates an existing referral program participation by ID.",
        request_body=ReferralProgramParticipationSerializer,
        responses={
            200: openapi.Response('Successful Response', ReferralProgramParticipationSerializer),
            400: 'Bad Request',
            404: 'Not Found',
            500: 'Internal Server Error'
        },
        tags=['referral_program_participation']
    )
    def put(self, request, participation_id=None):
        try:
            data = request.data
            participation = self.referral_program_participation_service.update_participation(participation_id, data, request)
            return Response(ReferralProgramParticipationSerializer(participation).data, status=status.HTTP_200_OK)
        except ReferralProgramParticipation.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error updating referral program participation: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Delete referral program participation",
        operation_description="Deletes a referral program participation by ID.",
        responses={
            204: 'No Content',
            404: 'Not Found',
            500: 'Internal Server Error'
        },
        tags=['referral_program_participation']
    )
    def delete(self, request, participation_id=None):
        try:
            self.referral_program_participation_service.delete_participation(participation_id)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except ReferralProgramParticipation.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error deleting referral program participation: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
"""18. ReferralProgramService
Servizio per gestire i programmi referral.
"""
class ReferralProgramService:
    def __init__(self):
        pass

    def get_referral_programs(self) -> List[ReferralProgram]:
        try:
            return ReferralProgram.objects.all()
        except ReferralProgram.DoesNotExist:
            logger.warning("ReferralProgram not found")
            raise ValueError("ReferralProgram not found")

    def create_referral_program(self, data, request) -> ReferralProgram:
        try:
            referral_program = ReferralProgram(
                name=data.get('name'),
                description=data.get('description'),
                start_date=data.get('start_date'),
                end_date=data.get('end_date')
            )
            referral_program.save()
            logger.info(f"ReferralProgram created: {referral_program}")
            return referral_program
        except Exception as e:
            logger.error(f"Error creating referral program: {e}")
            raise e
"""19. ReferralRewardService
Servizio per gestire i premi referral.
"""
class ReferralRewardService:
    def __init__(self):
        pass

    def create_referral_reward(self, data, request) -> ReferralReward:
        try:
            referral_reward = ReferralReward(
                referral_program=data.get('referral_program'),
                reward_type=data.get('reward_type'),
                reward_value=data.get('reward_value')
            )
            referral_reward.save()
            logger.info(f"ReferralReward created: {referral_reward}")
            return referral_reward
        except Exception as e:
            logger.error(f"Error creating referral reward: {e}")
            raise e
"""Proseguiamo con le altre entità come ReferralSettings, ReferralStats, ReferralTransaction e ReferralUser nei prossimi passi. Fammi sapere se hai bisogno di personalizzazioni!



CONTINUA
 said:
Proseguiamo con le entità rimanenti:

20. ReferralSettingsService
Servizio per gestire le impostazioni del programma referral.
"""
class ReferralSettingsService:
    def __init__(self):
        pass

    def get_settings(self) -> ReferralSettings:
        try:
            return ReferralSettings.objects.first()  # Assumiamo che ci sia una sola riga
        except ReferralSettings.DoesNotExist:
            logger.warning("ReferralSettings not found")
            raise ValueError("ReferralSettings not found")

    def update_settings(self, data, request) -> ReferralSettings:
        try:
            settings = self.get_settings()
            for key, value in data.items():
                setattr(settings, key, value)
            settings.save()
            logger.info(f"ReferralSettings updated: {settings}")
            return settings
        except ReferralSettings.DoesNotExist:
            logger.warning("ReferralSettings not found")
            raise ValueError("ReferralSettings not found")
        except Exception as e:
            logger.error(f"Error updating referral settings: {e}")
            raise e
"""21. ReferralStatsService
Servizio per raccogliere e analizzare le statistiche del programma referral.
"""
class ReferralStatsService:
    def __init__(self):
        pass

    def get_stats(self) -> dict:
        try:
            # Simuliamo un'aggregazione per le statistiche
            total_referrals = ReferralTransaction.objects.count()
            total_rewards = ReferralReward.objects.aggregate(Sum('reward_value'))['reward_value__sum']
            active_participants = ReferralProgramParticipation.objects.filter(active=True).count()
            
            stats = {
                "total_referrals": total_referrals,
                "total_rewards": total_rewards,
                "active_participants": active_participants
            }
            logger.info(f"ReferralStats: {stats}")
            return stats
        except Exception as e:
            logger.error(f"Error fetching referral stats: {e}")
            raise e
"""22. ReferralTransactionService
Servizio per gestire le transazioni referral.
"""
class ReferralTransactionService:
    def __init__(self):
        pass

    def create_transaction(self, data, request) -> ReferralTransaction:
        try:
            referral_transaction = ReferralTransaction(
                user=data.get('user'),
                transaction_type=data.get('transaction_type'),
                amount=data.get('amount'),
                referral_program=data.get('referral_program'),
                transaction_date=timezone.now()
            )
            referral_transaction.save()
            logger.info(f"ReferralTransaction created: {referral_transaction}")
            return referral_transaction
        except Exception as e:
            logger.error(f"Error creating referral transaction: {e}")
            raise e

    def get_transactions(self) -> List[ReferralTransaction]:
        try:
            return ReferralTransaction.objects.all()
        except ReferralTransaction.DoesNotExist:
            logger.warning("ReferralTransaction not found")
            raise ValueError("ReferralTransaction not found")
"""23. ReferralUserService
Servizio per gestire gli utenti che partecipano al programma referral.
"""
class ReferralUserService:
    def __init__(self):
        pass

    def get_user_referrals(self, user_id) -> List[ReferralUser]:
        try:
            return ReferralUser.objects.filter(user_id=user_id)
        except ReferralUser.DoesNotExist:
            logger.warning(f"ReferralUser not found for user {user_id}")
            raise ValueError("ReferralUser not found")

    def create_referral_user(self, data, request) -> ReferralUser:
        try:
            referral_user = ReferralUser(
                user=data.get('user'),
                referral_code=data.get('referral_code'),
                referrer=data.get('referrer'),
                join_date=timezone.now()
            )
            referral_user.save()
            logger.info(f"ReferralUser created: {referral_user}")
            return referral_user
        except Exception as e:
            logger.error(f"Error creating referral user: {e}")
            raise e
"""24. ReferralProgramAPIView
Vista per gestire il programma referral tramite API.
"""
class ReferralProgramAPIView(APIView):
    permission_classes = [IsAuthenticated]
    authentication_classes = [OAuth2Authentication]

    def __init__(self, *args, **kwargs):
        self.referral_program_service = ReferralProgramService()

    @swagger_auto_schema(
        operation_summary="Get all referral programs",
        operation_description="Returns a list of all referral programs.",
        responses={
            200: openapi.Response('Successful Response', ReferralProgramSerializer(many=True)),
            500: 'Internal Server Error'
        },
        tags=['referral_program']
    )
    def get(self, request, program_id=None):
        try:
            if program_id is None:
                programs = self.referral_program_service.get_referral_programs()
                serializer = ReferralProgramSerializer(programs, many=True)
                return Response(serializer.data, status=status.HTTP_200_OK)
            else:
                program = self.referral_program_service.get_referral_program(program_id)
                serializer = ReferralProgramSerializer(program)
                return Response(serializer.data, status=status.HTTP_200_OK)
        except ReferralProgram.DoesNotExist as e:
            return Response({'error': str(e)}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            logger.error(f"Error fetching referral program: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Create new referral program",
        operation_description="Creates a new referral program.",
        request_body=ReferralProgramSerializer,
        responses={
            201: openapi.Response('Created', ReferralProgramSerializer),
            400: 'Bad Request',
            500: 'Internal Server Error'
        },
        tags=['referral_program']
    )
    def post(self, request):
        try:
            data = request.data
            program = self.referral_program_service.create_referral_program(data, request)
            return Response(ReferralProgramSerializer(program).data, status=status.HTTP_201_CREATED)
        except Exception as e:
            logger.error(f"Error creating referral program: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
"""25. ReferralRewardAPIView
Vista per gestire i premi referral tramite API.
"""
class ReferralRewardAPIView(APIView):
    permission_classes = [IsAuthenticated]
    authentication_classes = [OAuth2Authentication]

    def __init__(self, *args, **kwargs):
        self.referral_reward_service = ReferralRewardService()

    @swagger_auto_schema(
        operation_summary="Create new referral reward",
        operation_description="Creates a new referral reward.",
        request_body=ReferralRewardSerializer,
        responses={
            201: openapi.Response('Created', ReferralRewardSerializer),
            400: 'Bad Request',
            500: 'Internal Server Error'
        },
        tags=['referral_reward']
    )
    def post(self, request):
        try:
            data = request.data
            reward = self.referral_reward_service.create_referral_reward(data, request)
            return Response(ReferralRewardSerializer(reward).data, status=status.HTTP_201_CREATED)
        except Exception as e:
            logger.error(f"Error creating referral reward: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
"""Abbiamo completato anche la gestione dei programmi referral, premi e transazioni.

Se vuoi che continui con ulteriori implementazioni o dettagli, fammi sapere!



CONTINUA
 said:
Proseguiamo con la parte finale delle entità e dei servizi. Questa volta continueremo con l'implementazione per le entità rimanenti.

26. ReferralCodeService
Servizio per gestire i codici referral.
"""
class ReferralCodeService:
    def __init__(self):
        pass

    def generate_referral_code(self, user) -> str:
        # Generiamo un codice unico per il referral (potresti usare una libreria per rendere il codice più sicuro)
        return f"{user.username[:5]}{str(uuid.uuid4())[:6]}"

    def get_referral_code(self, user_id) -> ReferralCode:
        try:
            return ReferralCode.objects.get(user_id=user_id)
        except ReferralCode.DoesNotExist:
            logger.warning(f"ReferralCode not found for user {user_id}")
            raise ValueError("ReferralCode not found")
    
    def create_referral_code(self, user) -> ReferralCode:
        code = self.generate_referral_code(user)
        referral_code = ReferralCode(
            user=user,
            code=code,
            created_at=timezone.now()
        )
        referral_code.save()
        logger.info(f"ReferralCode created for user {user.id}: {code}")
        return referral_code
"""27. ReferralConversionService
Servizio per gestire le conversioni dei referral.
"""
class ReferralConversionService:
    def __init__(self):
        pass

    def track_conversion(self, referral_code: str, conversion_type: str, amount: float) -> ReferralConversion:
        try:
            referral = ReferralCode.objects.get(code=referral_code)
            conversion = ReferralConversion(
                referral_code=referral,
                conversion_type=conversion_type,
                amount=amount,
                conversion_date=timezone.now()
            )
            conversion.save()
            logger.info(f"ReferralConversion tracked: {conversion}")
            return conversion
        except ReferralCode.DoesNotExist:
            logger.warning(f"ReferralCode {referral_code} not found")
            raise ValueError("ReferralCode not found")
        except Exception as e:
            logger.error(f"Error tracking conversion: {e}")
            raise e
"""28. ReferralEngagementService
Servizio per gestire l'engagement degli utenti nel programma referral.
"""
class ReferralEngagementService:
    def __init__(self):
        pass

    def track_engagement(self, user_id, action_type, action_value) -> ReferralEngagement:
        try:
            engagement = ReferralEngagement(
                user_id=user_id,
                action_type=action_type,
                action_value=action_value,
                action_date=timezone.now()
            )
            engagement.save()
            logger.info(f"ReferralEngagement tracked: {engagement}")
            return engagement
        except Exception as e:
            logger.error(f"Error tracking engagement: {e}")
            raise e
"""29. ReferralLevelService
Servizio per gestire i livelli degli utenti nel programma referral.
"""
class ReferralLevelService:
    def __init__(self):
        pass

    def get_user_level(self, user_id) -> ReferralLevel:
        try:
            level = ReferralLevel.objects.filter(user_id=user_id).first()
            if not level:
                level = ReferralLevel.objects.create(user_id=user_id, level=1)  # Default to level 1
            return level
        except Exception as e:
            logger.error(f"Error fetching referral level: {e}")
            raise e

    def upgrade_level(self, user_id, new_level) -> ReferralLevel:
        try:
            level = self.get_user_level(user_id)
            level.level = new_level
            level.save()
            logger.info(f"ReferralLevel upgraded for user {user_id}: {new_level}")
            return level
        except Exception as e:
            logger.error(f"Error upgrading referral level: {e}")
            raise e
"""30. ReferralSupportTicketService
Servizio per gestire i ticket di supporto per il programma referral.
"""
class ReferralSupportTicketService:
    def __init__(self):
        pass

    def create_ticket(self, user, issue_description) -> ReferralSupportTicket:
        try:
            ticket = ReferralSupportTicket(
                user=user,
                issue_description=issue_description,
                status='open',
                created_at=timezone.now()
            )
            ticket.save()
            logger.info(f"ReferralSupportTicket created: {ticket}")
            return ticket
        except Exception as e:
            logger.error(f"Error creating support ticket: {e}")
            raise e

    def get_ticket_status(self, ticket_id) -> str:
        try:
            ticket = ReferralSupportTicket.objects.get(id=ticket_id)
            return ticket.status
        except ReferralSupportTicket.DoesNotExist:
            logger.warning(f"ReferralSupportTicket {ticket_id} not found")
            raise ValueError("ReferralSupportTicket not found")
"""31. ReferralProgramParticipationService
Servizio per gestire la partecipazione degli utenti al programma referral.
"""
class ReferralProgramParticipationService:
    def __init__(self):
        pass

    def participate_in_program(self, user, referral_program) -> ReferralProgramParticipation:
        try:
            participation = ReferralProgramParticipation(
                user=user,
                referral_program=referral_program,
                participation_date=timezone.now()
            )
            participation.save()
            logger.info(f"ReferralProgramParticipation created for user {user.id} in program {referral_program.id}")
            return participation
        except Exception as e:
            logger.error(f"Error creating referral program participation: {e}")
            raise e

    def get_user_participation(self, user_id) -> List[ReferralProgramParticipation]:
        try:
            return ReferralProgramParticipation.objects.filter(user_id=user_id)
        except ReferralProgramParticipation.DoesNotExist:
            logger.warning(f"ReferralProgramParticipation not found for user {user_id}")
            raise ValueError("ReferralProgramParticipation not found")
"""32. ReferralProgramAPIView (Update)
Vista per la gestione dei programmi referral con metodi di partecipazione.
"""
class ReferralProgramAPIView(APIView):
    permission_classes = [IsAuthenticated]
    authentication_classes = [OAuth2Authentication]

    def __init__(self, *args, **kwargs):
        self.referral_program_service = ReferralProgramService()
        self.participation_service = ReferralProgramParticipationService()

    @swagger_auto_schema(
        operation_summary="Get referral program participation status",
        operation_description="Returns the user's participation in a referral program.",
        responses={
            200: openapi.Response('Successful Response', ReferralProgramParticipationSerializer(many=True)),
            500: 'Internal Server Error'
        },
        tags=['referral_program']
    )
    def get(self, request):
        try:
            user_id = request.user.id
            participations = self.participation_service.get_user_participation(user_id)
            serializer = ReferralProgramParticipationSerializer(participations, many=True)
            return Response(serializer.data, status=status.HTTP_200_OK)
        except Exception as e:
            logger.error(f"Error fetching referral program participation: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Participate in referral program",
        operation_description="Allows a user to participate in a referral program.",
        request_body=ReferralProgramParticipationSerializer,
        responses={
            201: openapi.Response('Created', ReferralProgramParticipationSerializer),
            400: 'Bad Request',
            500: 'Internal Server Error'
        },
        tags=['referral_program']
    )
    def post(self, request):
        try:
            user = request.user
            data = request.data
            program_id = data.get('referral_program_id')
            referral_program = ReferralProgram.objects.get(id=program_id)
            participation = self.participation_service.participate_in_program(user, referral_program)
            return Response(ReferralProgramParticipationSerializer(participation).data, status=status.HTTP_201_CREATED)
        except Exception as e:
            logger.error(f"Error participating in referral program: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
"""Con questo, abbiamo completato le implementazioni per tutte le entità e i servizi associati alle funzionalità di programma di referral. Se desideri continuare con altri aspetti o modifiche, fammi sapere!



CONTNUA CON LE ALTRE ENTITA RIMASTE DI REFERRAL
 said:
Continuo con la parte rimanente delle entità di Referral. Andiamo avanti con la gestione delle entità che mancano per completare l'integrazione delle classi Referral.

33. ReferralStatsService
Servizio per gestire le statistiche degli utenti nel programma referral.
"""
class ReferralStatsService:
    def __init__(self):
        pass

    def get_user_stats(self, user_id) -> ReferralStats:
        try:
            stats = ReferralStats.objects.get(user_id=user_id)
            return stats
        except ReferralStats.DoesNotExist:
            logger.warning(f"ReferralStats not found for user {user_id}")
            raise ValueError("ReferralStats not found")

    def update_user_stats(self, user_id, new_stats_data) -> ReferralStats:
        try:
            stats = self.get_user_stats(user_id)
            stats.referrals_made = new_stats_data['referrals_made']
            stats.referrals_converted = new_stats_data['referrals_converted']
            stats.referral_bonus_earned = new_stats_data['referral_bonus_earned']
            stats.save()
            logger.info(f"ReferralStats updated for user {user_id}")
            return stats
        except Exception as e:
            logger.error(f"Error updating referral stats: {e}")
            raise e
"""34. ReferralTransactionService
Servizio per gestire le transazioni di referral.
"""
class ReferralTransactionService:
    def __init__(self):
        pass

    def create_referral_transaction(self, user, amount, transaction_type) -> ReferralTransaction:
        try:
            transaction = ReferralTransaction(
                user=user,
                amount=amount,
                transaction_type=transaction_type,
                transaction_date=timezone.now()
            )
            transaction.save()
            logger.info(f"ReferralTransaction created for user {user.id}: {transaction}")
            return transaction
        except Exception as e:
            logger.error(f"Error creating referral transaction: {e}")
            raise e

    def get_user_transactions(self, user_id) -> List[ReferralTransaction]:
        try:
            transactions = ReferralTransaction.objects.filter(user_id=user_id)
            return transactions
        except Exception as e:
            logger.error(f"Error fetching referral transactions: {e}")
            raise e
"""35. ReferralUserService
Servizio per gestire gli utenti del programma referral.
"""
class ReferralUserService:
    def __init__(self):
        pass

    def get_user(self, user_id) -> ReferralUser:
        try:
            return ReferralUser.objects.get(id=user_id)
        except ReferralUser.DoesNotExist:
            logger.warning(f"ReferralUser {user_id} not found")
            raise ValueError("ReferralUser not found")

    def create_or_update_user(self, user_data) -> ReferralUser:
        try:
            user, created = ReferralUser.objects.update_or_create(
                email=user_data['email'],
                defaults=user_data
            )
            action = 'created' if created else 'updated'
            logger.info(f"ReferralUser {action}: {user}")
            return user
        except Exception as e:
            logger.error(f"Error creating or updating referral user: {e}")
            raise e
"""36. ReferralProgramService
Servizio per gestire i programmi di referral.
"""
class ReferralProgramService:
    def __init__(self):
        pass

    def create_referral_program(self, program_data) -> ReferralProgram:
        try:
            program = ReferralProgram(**program_data)
            program.save()
            logger.info(f"ReferralProgram created: {program}")
            return program
        except Exception as e:
            logger.error(f"Error creating referral program: {e}")
            raise e

    def get_referral_program(self, program_id) -> ReferralProgram:
        try:
            return ReferralProgram.objects.get(id=program_id)
        except ReferralProgram.DoesNotExist:
            logger.warning(f"ReferralProgram {program_id} not found")
            raise ValueError("ReferralProgram not found")
    
    def get_all_programs(self) -> List[ReferralProgram]:
        return ReferralProgram.objects.all()
"""37. ReferralRewardService
Servizio per gestire le ricompense di referral.
"""
class ReferralRewardService:
    def __init__(self):
        pass

    def create_reward(self, user, reward_data) -> ReferralReward:
        try:
            reward = ReferralReward(
                user=user,
                reward_type=reward_data['reward_type'],
                amount=reward_data['amount'],
                reward_date=timezone.now()
            )
            reward.save()
            logger.info(f"ReferralReward created for user {user.id}: {reward}")
            return reward
        except Exception as e:
            logger.error(f"Error creating referral reward: {e}")
            raise e

    def get_user_rewards(self, user_id) -> List[ReferralReward]:
        try:
            rewards = ReferralReward.objects.filter(user_id=user_id)
            return rewards
        except ReferralReward.DoesNotExist:
            logger.warning(f"ReferralReward not found for user {user_id}")
            raise ValueError("ReferralReward not found")
"""38. ReferralSettingsService
Servizio per gestire le impostazioni del programma referral.
"""
class ReferralSettingsService:
    def __init__(self):
        pass

    def get_settings(self) -> ReferralSettings:
        try:
            settings = ReferralSettings.objects.first()  # Assuming only one settings record
            return settings
        except ReferralSettings.DoesNotExist:
            logger.warning("ReferralSettings not found")
            raise ValueError("ReferralSettings not found")

    def update_settings(self, settings_data) -> ReferralSettings:
        try:
            settings = self.get_settings()
            for key, value in settings_data.items():
                setattr(settings, key, value)
            settings.save()
            logger.info(f"ReferralSettings updated: {settings}")
            return settings
        except Exception as e:
            logger.error(f"Error updating referral settings: {e}")
            raise e
"""39. ReferralNotificationService
Servizio per inviare notifiche agli utenti nel programma referral.
"""
class ReferralNotificationService:
    def __init__(self):
        pass

    def send_notification(self, user, message) -> ReferralNotification:
        try:
            notification = ReferralNotification(
                user=user,
                message=message,
                notification_date=timezone.now()
            )
            notification.save()
            logger.info(f"ReferralNotification sent to user {user.id}: {message}")
            return notification
        except Exception as e:
            logger.error(f"Error sending referral notification: {e}")
            raise e

    def get_user_notifications(self, user_id) -> List[ReferralNotification]:
        try:
            notifications = ReferralNotification.objects.filter(user_id=user_id)
            return notifications
        except Exception as e:
            logger.error(f"Error fetching user notifications: {e}")
            raise e
"""40. ReferralCodeAPIView
Vista per la gestione dei codici referral.
"""
class ReferralCodeAPIView(APIView):
    permission_classes = [IsAuthenticated]
    authentication_classes = [OAuth2Authentication]

    def __init__(self, *args, **kwargs):
        self.referral_code_service = ReferralCodeService()

    @swagger_auto_schema(
        operation_summary="Get referral code",
        operation_description="Fetch the referral code for the logged-in user.",
        responses={
            200: openapi.Response('Successful Response', ReferralCodeSerializer),
            500: 'Internal Server Error'
        },
        tags=['referral_code']
    )
    def get(self, request):
        try:
            user_id = request.user.id
            referral_code = self.referral_code_service.get_referral_code(user_id)
            serializer = ReferralCodeSerializer(referral_code)
            return Response(serializer.data, status=status.HTTP_200_OK)
        except Exception as e:
            logger.error(f"Error fetching referral code: {e}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @swagger_auto_schema(
        operation_summary="Create referral code",
        operation_description="Generate a new referral code for the user.",
        request_body=ReferralCodeSerializer,
        responses={
            201: openapi.Response('Created', ReferralCodeSerializer),
            400: 'Bad Request',
            500: 'Internal Server Error'
        },
        tags=['referral_code']
    )
    def post(self, request):
        try:
            user = request.user
            referral_code = self.referral_code_service.create_referral_code(user)
            return Response(ReferralCodeSerializer(referral_code).data, status=status.HTTP_201_CREATED)
        except Exception as e:
            logger.error(f"Error creating referral code: {e}")
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
